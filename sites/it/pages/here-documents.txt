=title Here Document, ovvero come creare stringhe multi-linea in Perl
=timestamp 2013-08-04T22:00:00
=indexes <<, /m, /g, q, qq
=status show
=original here-documents
=books beginner
=author szabgab
=translator giatorta
=comments_disqus_enable 0

=abstract start

Ogni tanto può capitarvi di dover creare una stringa che occupa diverse linee.
Come al solito, in Perl ci sono molte soluzioni per questo problema.
Una soluzione comune consiste nell'uso di un here-document.

=abstract end

Un <b>here-document</b> vi permette di creare una stringa che occupa <b>diverse linee</b> preservando
i caratteri di spaziatura e di a capo. Se eseguite il codice qui sotto verrà stampato esattamente ciò che vedete
dalla parola Caro fino alla linea che precede la seconda occorrenza di END_MESSAGE.

<h2>Non-interpolating here document</h2>

<code lang="perl">
#!/usr/bin/perl
use strict;
use warnings;

my $name = 'Pippo';

my $message = <<'END_MESSAGE';
Caro $name,

questo e' un messaggio che vorrei spedirti.

saluti
  firmato: il Perl Maven
END_MESSAGE

print $message;
</code>

L'output è:

<code>
Caro $name,

questo e' un messaggio che vorrei spedirti.

saluti
  firmato: il Perl Maven
</code>

L'here document inizia con due caratteri minore-di <hl>&lt;&lt;</hl> seguiti da una stringa arbitraria che diventa
il terminatore dell'here-document, seguita dal punto e virgola <hl>;</hl> che chiude l'istruzione.
Può sembrare un po' strano dato che l'istruzione non termina davvero lì. Infatti il contenuto dell'here document
inizia alla linea successiva al punto e virgola (nel nostro caso con la parola "Caro") e continua finché perl trova il
terminatore scelto arbitrariamente. Nel nostro caso la stringa <b>END_MESSAGE</b>.

Se vi è già capitato di vedere degli here-document in qualche pezzo di codice, probabilmente sarete sorpresi dalla presenza degli apici intorno al primo <b>END_MESSAGE</b>. Credo che se trovate degli esempi di here-document in Internet, o anche dietro ai firewall aziendali,
probabilmente vedrete la parte iniziale senza apici. Come in questo codice:

<code lang="perl">
my $message = <<END_MESSAGE;
...
END_MESSAGE
</code>

Funziona e si comporta come se aveste racchiuso END_MESSAGE tra doppi apici come nel prossimo esempio,
ma è <b>deprecato</b> e sarà rimosso a partire da perl 5.20. Quindi <b>non</b> usatelo! Non usate here-document
senza racchiudere tra apici la definizione della stringa-terminatore.

<code lang="perl">
my $message = <<"END_MESSAGE";
...
END_MESSAGE
</code>

Se conoscete già la
<a href="/quoted-interpolated-and-escaped-strings-in-perl">differenza tra apici singoli e doppi</a>
in Perl non vi sorprenderà che gli here-document si comportino nello stesso modo.
L'unica differenza è che gli apici vengono messi
intorno, al terminatore anziché alla stringa vera e propria. Se omettete gli apici, Perl assume per default i doppi apici.

Se riguardate il primo esempio, noterete che <hl>$name</hl> faceva parte dell'here-document
e che continuava a far parte anche dell'output. Questo perché Perl non tentava di sostituirlo
con il contenuto della variabile <hl>$name</hl>. (Non dovevamo neppure dichiarare la variabile nel
codice. Potete provare lo script anche senza la parte <hl>my $name = 'Pippo';</hl>.)

<h2>Interpolazione di here document</h2>

Nel prossimo esempio racchiuderemo il terminatore tra doppi apici in modo che la variabile <hl>$name</hl>
venga interpolata:

<code lang="perl">
use strict;
use warnings;

my $name = 'Pippo';
my $message = <<"END_MSG";
Ciao $name,

come stai?
END_MSG

print $message;
</code>

Il risultato dell'esecuzione di questo script è:

<code>
Ciao Pippo,

come stai?
</code>

<h2>Attenzione: alla fine ci vuole il terminatore corretto</h2>

Solo una nota. Dovete assicurarvi che la stringa-terminatore alla fine della stringa
sia <b>esattamente</b> uguale a quella che c'è all'inizio. Nessun carattere di spaziatura prima o dopo.
Altrimenti Perl non la riconoscerà e penserà che l'here-document non sia ancora finito.
Ciò significa che non potete indentare il terminatore per seguire l'indentazione del resto del vostro codice.
O invece sì?

<h2>Here document e indentazione del codice</h2>

Se l'here document deve essere definito in un posto dove normalmente indentereste
il codice, abbiamo due problemi:


<code lang="perl">
#!/usr/bin/perl
use strict;
use warnings;

my $name = 'Pippo';
my $send = 1;

if ($send) {
    my $message = <<"END_MESSAGE";
        Caro $name,
    
        questo e' un messaggio che vorrei spedirti.
    
        saluti
          firmato: il Perl Maven
END_MESSAGE
    print $message;
}
</code>

Uno è che, come detto sopra, il terminatore della stringa deve essere esattamente lo stesso sia quando viene
dichiarato che quando chiude la stringa, e quindi non potete indentarlo alla fine della stringa. 

L'altro problema è che l'output conterrà molti caratteri di spaziatura all'inizio di ogni linea:

<code>
        Caro Pippo,
    
        questo e' un messaggio che vorrei spedirti.
    
        saluti
          firmato: il Perl Maven
</code>

L'assenza di indentazione del terminatore può essere risolta usandone uno che
includa un numero sufficiente di spazi iniziali: (qui uso 4 spazi, dato che i tab non
vanno bene qui nell'articolo, ma potrebbero funzionare in un pezzo di codice reale. Sempre che siate dei patiti
di indentazione coi tab.)

<code lang="perl">
    my $message = <<"    END_MESSAGE";
       ...
    END_MESSAGE
</code>

L'indentazione extra del testo vero e proprio può essere rimossa aggiungendo una sostituzione nell'assegnamento.

<code lang="perl">
    (my $message = <<"    END_MESSAGE") =~ s/^ {8}//gm; 
        ...
    END_MESSAGE
</code>

Nella sostituzione rimpiazziamo 8 spazi iniziali con la stringa vuota. Usiamo due modificatori:
<hl>/m</hl> cambia il comportamento di <hl>^</hl> in modo che faccia il match all'<b>inizio della linea</b>
anziché all'<b>inizio della stringa</b>.  <hl>/g</hl> dice a perl di fare una sostituzione <b>globale</b>,
ovvero di ripetere la sostituzione tante volte quanto è possibile.

Insieme questi due flag hanno l'effetto di far rimuovere alla sostituzione 8 spazi iniziali da ogni linea nella
variabile a sinistra di <hl>=~</hl>.
A sinistra abbiamo dovuto mettere l'assegnmento tra parentesi perché la precedenza
dell'operatore di assegnamento (<hl>=</hl>) è più bassa di quella del match <hl>=~</hl>. Senza
le parentesi, perl proverebbe per prima cosa ad applicare la regex di sostituzione all'here-document stesso
generando un errore di compilazione:

Can't modify scalar in substitution (s///) at programming.pl line 9, near "s/^ {8}//gm;"

<h2>Usare le alternative q e qq</h2>

Ora che ho finito la mia spiegazione, posso confessare che non sono sicuro di consigliarvi di usare gli here-document.
Personalmente, in molti casi, invece degli here-document uso gli operatori <hl>qq</hl> e <hl>q</hl>.
A seconda che voglia o non voglia interpolare le stringhe:

<code lang="perl">
#!/usr/bin/perl
use strict;
use warnings;

my $name = 'Pippo';
my $send = 1;

if ($send) {
    (my $message = qq{
        Caro $name,

        questo e' un messaggio che vorrei spedirti.
    
        saluti
          firmato: il Perl Maven
        }) =~ s/^ {8}//mg;
    print $message;
}
</code>


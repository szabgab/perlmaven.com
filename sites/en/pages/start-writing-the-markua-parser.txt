=title Start writing the Markua parser in Perl
=timestamp 2018-03-02T10:30:01
=indexes Markua, Test::More, is_deeply, git, Path::Tiny, path, JSON::MaybeXS, decode_json
=status show
=author szabgab
=archive 1
=comments_disqus_enable 0
=sample 1

=abstract start

<a href="https://leanpub.com/markua/">Markua</a> is a Magical Typewriter. It is a <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>-inspired
format to write books. It was created by <a href="https://twitter.com/peterarmstrong">Peter Armstrong</a> and use by <a href="https://leanpub.com/">LeanPub</a> 
for writing books.

In this project I am going to create a Markua parser in Perl 5, or at least I start doing it and will implement enough of so I can start writing the Perl Maven
articles in Markua. That will allow me to easily include Perl Maven articles in an eBook published on LeanPub.
For example to create the <a href="https://www.indiegogo.com/projects/updating-the-perl-maven-tutorial/reft/775728/pmarticle0302">eBook of the Perl Maven Tutorial</a>.

=abstract end

<h2>Set up Git and GitHub repository</h2>

On my local disk created a new directory called "perl5-markua-parser", and in it a README.md file which is a readme file written in Markdown
format for GitHub to display nicely.

<code>
$ mkdir perl5-markua-parser
$ cd perl5-markua-parser

# Created README.md using vim
</code>

The README.md file:

<include file="examples/markua-parser/605d7df/README.md">

Set it up as a local git repository and committed the first change:

<code>
$ git init
$ git add README.md
$ git commit -m "start with a readme"
</code>

Then I've created a new repository on GitHub called <a href="https://github.com/szabgab/perl5-markua-parser">perl5-markua-parser</a>,
I've told my local git repository about the remote repository, and pushed out the first changes.

<code>
$ git remote add origin git@github.com:szabgab/perl5-markua-parser.git
$ git push -u origin master
</code>

<a href="https://github.com/szabgab/perl5-markua-parser/commit/605d7df604a819748a3ab393c44e19f59a478183">commit</a>.

<h2>Create constructor and test it</h2>

Before we start writing the parser, let's create the skeleton of the module with a constructor and a test-case for them.
I've created a directory called "lib/Markua" and a file called "Parser.pm" in it.

<code>
$ mkdir -p lib/Markua
</code>

<include file="examples/markua-parser/532b1b1/lib/Markua/Parser.pm">

For details read <a href="/getting-started-with-classic-perl-oop">getting started with classic Perl OOP</a> or 
<a href="/core-perl-oop-constructor">constructor in core Perl</a>.

The corresponding test was saved in the new 't' directory we just created:

<code>
$ mkdir t
</code>

<include file="examples/markua-parser/532b1b1/t/01-test.t">

Nothing fancy. Just checking if the generated object is an instance of the class.

We can run the tests by typing in

<code>
$ prove -l
</code>


<code>
$ git add .
$ git commit -m "create module with constructor and test it"
</code>

<a href="https://github.com/szabgab/perl5-markua-parser/commit/532b1b17c3520a1a9508e26c460d9e42b9c6a5d4">commit</a>

<h2>Start parsing</h2>

Before writing the parser, let's write a simple test-case for it.
In the 't' directory I've created a subdirectory called 'input' where we are going to store the sample input files.

<code>
$ mkdir t/input
</code>

In there I've created a simple Markua file:

<include file="examples/markua-parser/491850e/t/input/heading1.md">

The parser is expected to create a Perl data structure.

I've also created a directory called 't/dom' that will contain the expected data structures in JSON format.
(DOM stands for Document Object Model.)

<code>
$ mkdir t/dom
</code>

In there I've placed the first such JSON file:

<include file="examples/markua-parser/491850e/t/dom/heading1.json">

In the test file we load two modules, <a href="https://metacpan.org/pod/Path::Tiny">Path::Tiny</a> for
easy reading of the JSON file and <a href="https://metacpan.org/pod/JSON::MaybeXS">JSON::MaybeXS</a>
to parse the JSON string.

<code lang="perl">
use JSON::MaybeXS qw(decode_json);
use Path::Tiny qw(path);
</code>

the test code itself is another 2 lines:

<code lang="perl">
my $result = $m->parse_file('t/input/heading1.md');
is_deeply $result, decode_json( path('t/dom/heading1.json')->slurp_utf8 );
</code>

In the first line we use the not yet implemented <hl>parse_file</hl> method that
receives the path to the Markua file and returns the data structure. Or so it will
do once we implement it. The second line uses the <hl>is_deeply</hl> function from 
Test::More to compare the data structure generated by the Markua parser to the expected
data structure that was read in from the JSON file and converted to a Perl data structure
by <hl>decode_json</hl>.

The full test file is here:

<include file="examples/markua-parser/491850e/t/01-test.t">

Then finally the implementation of the parser itself uses Path::Tiny to read in the Markua
source file and then uses regexes to parse the lines. Very simple, but works for the first test
case:

<include file="examples/markua-parser/491850e/lib/Markua/Parser.pm">

The <hl>parse_file</hl> method expects two paramers. The instance object represnting the current parser
and the name of the file to be parsed.

We create an empty array called <hl>@entries</hl> that will hold the parsed DOM.

Then we ue the <hl>lines_utf8</hl> method of the <hl>Path::Tiny</a> object to read in all the lines of the
Markua file and go over line-by-line using a <hl>for</hl> loop.

In the <hl>/^# (\S.*)/</hl> <a href="/regex">regex</a> the leading <hl>^</hl> forces the regex to look for a match at the beginning of the sting. <hl># </hl> then tells it to match those two character immediately after the beginning of the string. Whatever is matched by the rge within the pair of parentheses <hl>()</hl> will be saved in the variable <hl>$1</hl>. In the regex inside the parentheses <hl>\S</hl> means any non-white-space character, <hl>.</hl> means any character (except of newline) and <hl>*</hl> tells the dot to match 0 or more so in other words the regex inside the parentheses will match any string of any length, it just has to start with something visible. (So there can't be 2 spaces after the initial <hl>#</hl>.)

I am not sure if this is the correct regex for the specification of Markua, for that I'd need to read it more thoroughly, but for now it works for us and it satisfies our test. We can always improve it later.

If the regex matches we create an reference to a hash with the name of the tag <hl>h1</hl> and the value or "text" of it which the text that followed the <hl>#</hl>. We take the anonymous hash and <a href="/manipulating-perl-arrays">push</a> it (append it) to the <hl>@entries</hl> array.

At the end we return a <a href="/array-references-in-perl">reference</a> to the <hl>@entries</hl> array.

<code>
$ git add .
$ git commit -m "first parsing of an h1 tag"
$ git push
</code>

<a href="https://github.com/szabgab/perl5-markua-parser/commit/491850ef6a6c7b5a79ef436dd407e497a5a2b2c5">commit</a>

<h2>To be continued</h2>

In the meantime go and support the <a href="https://www.indiegogo.com/projects/updating-the-perl-maven-tutorial/reft/775728/pmarticle0302">crowdfunding campaign</a>.

<h2>Comments</h2>

Why not use: 1) a Moose-like object system like Mo. Moo, Mops, 2) real parser like Marpa or Regexp::Grammar?
---
I don't think M* has any added value at this point in the development and I don't know those parsers. But I'll consider both as suggestions for later on.

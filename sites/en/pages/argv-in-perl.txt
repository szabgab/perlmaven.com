=title Processing command line arguments - @ARGV in Perl
=timestamp 2013-07-07T17:13:10
=description In Perl @ARGV contains the raw command line arguments as passed by the user running the script
=indexes @ARGV, $ARGV[], $0, shift, argc
=status show
=books beginner
=author szabgab
=comments_disqus_enable 1

=abstract start

If you wrote a Perl script, for example <b>programming.pl</b>,
your users can run the script on the command line using <b>perl programming.pl</b>.

They can also pass any command line arguments like this <b>perl programming.pl -a --machine remote /etc</b>.
No one will stop the users from doing that, and the script will disregard these values.
The question then how can you, the author of the script, know which values were passed, if any?

=abstract end

<h2>Command line</h2>

Perl automatically provides an array called <hl>@ARGV</hl>, that holds all the values from the command line.
You don't have to declare the variable, even if you <hl>use strict</hl>.

This variable always exists and the values from the command line are automatically placed in this variable.

If there are no parameters, the array will be empty. If there is one parameter on the command line, that value will
be the only element in <hl>@ARGV</hl>. In the above example the <hl>@ARGV</hl> will have the following elements:
-a, --machine, remote, /etc

Let's see this in action:

Save this code as <b>programming.pl</b>:

<code lang="perl">
use strict;
use warnings;
use Data::Dumper qw(Dumper);

print Dumper \@ARGV;
</code>

Run it like this: <hl>perl programming.pl -a --machine remote /etc</hl> and this is the output:

<code>
$VAR1 = [
          '-a',
          '--machine',
          'remote',
          '/etc'
        ];
</code>

As you can see we used the <hl>Dumper</hl> function of <hl>Data::Dumper</hl> to print
out the content of <hl>@ARGV</hl>

If you are coming from another programming language, you might be wondering:
<b>where is the name of the Perl program?</b>

<h2>The name of the script is in $0</h2>

The name of the program being executed, in the above case <b>programming.pl</b>, is always in the <hl>$0</hl>
variable of Perl. (Please note, <hl>$1</hl>, <hl>$2</hl>, etc. are unrelated!)

<screencast file="welcome-to-perlmaven" youtube="nr3SSEjdpgg" />

<h2>C programmer</h2>

In case you know the <b>C programming language</b>, this is similar to <b>argv</b>, except that the
<hl>@ARGV</hl> of Perl does <b>not</b> contain the name of the program.
It can be found in the <hl>$0</hl> variable. Also a variable such as <b>argc</b> is not necessary,
as you can easily get the <a href="/scalar-and-list-context-in-perl">number of elements in the @ARGV array</a>
using the <hl>scalar</hl> function or by putting the array in
<a href="/scalar-and-list-context-in-perl">scalar context</a>.

<h2>Unix/Linux Shell programming</h2>

In case you arrive from the world of <b>Unix/Linux Shell programming</b> you will recognize <hl>$0</hl>
is being the name of the script there too. In shell however <hl>$1</hl>, <hl>$2</hl>, etc.
hold the rest of the command line parameters. These variables are used by
the regular expressions of Perl. The command line arguments are in <hl>@ARGV</hl>. Similar to <hl>$*</hl>
in the Unix/Linux shell.

<h2>How to extract the command line arguments from @ARGV</h2>

<hl>@ARGV</hl> is just a regular <a href="/perl-arrays">array in Perl</a>.
The only difference from arrays that you create, is that it does not
need to be declared and it is populated by Perl when your script starts.

Aside from these issue, you can handle it as a <a href="/perl-arrays">regular array</a>.
You can go over the elements using <hl>foreach</hl>, or access them one by one using an index: <hl>$ARGV[0]</hl>.

You can also use <a href="/manipulating-perl-arrays">shift, unshift, pop or push</a> on this array.

Indeed, not only can you fetch the content of <hl>@ARGV</hl>, you can also change it.

If you expect a single value on the command line you can check what was it, or if it was provided at all
by looking at <hl>$ARGV[0]</hl>. If you expect two variables you will also check <hl>$ARGV[1]</hl>.

For example, let's create a phone book. If you provide one name, the application will print the corresponding phone
number. If you give a name and a number the program will save that pair in the "database".
(We won't actually handle the "database" part of the code, we just pretend we have something.)

We know that the parameters will arrive in <hl>$ARGV[0]</hl> and maybe also in <hl>$ARGV[1]</hl>, but
those have no meaning besides being the first and second element of an array.
Usually it is better to use your own named variables in your code instead of $ARGV[0] and similar.
So the first thing we'll want is to copy the values to variables with representative names:

This can work:

<code lang="perl">
my $name   = $ARGV[0];
my $number = $ARGV[1];
</code>

But this is much nicer:

<code lang="perl">
my ($name, $number) = @ARGV;
</code>

Let's now see the full example (well, except of the database part).
Save the following code in <b>programming.pl</b>.

<code lang="perl">
use strict;
use warnings;

my ($name, $number) = @ARGV;

if (not defined $name) {
  die "Need name\n";
}

if (defined $number) {
  print "Save '$name' and '$number'\n";
  # save name/number in database
  exit;
}

print "Fetch '$name'\n";
# look up the name in the database and print it out
</code>

After copying the values from <hl>@ARGV</hl>, we check if the name was provided.
If not, we call <hl>die</hl> that will print an error message and exit the script.

If there was a name, then we check for the number. If there was a number we save
it in the database (which is not implemented above) and exit the script.

If there was no number then we try to fetch it from the database. (Again, not implemented here.)

Let's see how it works: (The $ sign only marks the prompt, we don't type that.)

<code>
$ perl programming.pl Foo 123
Save 'Foo' and '123'

$ perl programming.pl Bar 456
Save 'Bar' and '456'

$ perl programming.pl John Doe 789
Save 'John' and 'Doe'
</code>

The first two calls were OK, but the last one does not look good.
We wanted to save the phone number of "John Doe" to be 789, but instead of that
our script saved the phone number of "John" as if it was "Doe".

The reason is simple, and it has nothing to do with Perl. This would work the same in any other language.
The shell or command line, where you run the script takes the line apart and passes the values to perl which then
puts them in <hl>@ARGV</hl>. Both the Unix/Linux shell and the Windows Command Line will split the command line
at every space. So when we typed <hl>perl programming.pl John Doe 789</hl>, the shell actually passed 3 parameters to
our script. In order to make it work correctly the user has to put the values that have embedded spaces inside quotes:

<code>
$ perl a.pl "John Doe" 789
Save 'John Doe' and '789'
</code>

You, as the programmer cannot do much about this.

<h2>Checking the arguments</h2>

Maybe you could check if the number of elements does not exceed the number you expected.
It would stop the user from making the above mistake, but what if the user wants
to fetch the phone number of John Doe and forgets the quotes:

<code>
perl a.pl John Doe
Save 'John' and 'Doe'
</code>

In this case there were 2 parameters which is the correct number of arguments.

Here too, you could make a slight improvement and check if the content of the <hl>$number</hl> variable
is in a format you accept as phone number. That would reduce the possibility for mistakes in this case.
That still would not be perfect and certainly not an universal solution:
In other applications there might be several parameters with the same constraints.

Unfortunately there is not a lot we can do when parsing <hl>@ARGV</hl> "manually".
In another article I'll write about <hl>Getopt::Long</hl> and similar libraries
that make life a bit easier, but let's see another simple case now.


<h2>shift a single parameter</h2>

A common case is when you expect the user to provide a single filename on the command line.
In that case you could write the following code:

<code lang="perl">
my $filename = shift or die "Usage: $0 FILENAME\n";
</code>

Let's break that line into two parts for easier explanation:
<hl>my $filename = shift</hl>

Normally <a href="/manipulating-perl-arrays">shift</a> would get an array as its parameter,
but in this case we used it without a parameter. In such cases shift defaults to work
on <hl>@ARGV</hl>. So the above code will move the first value of <hl>@ARGV</hl> to the
<hl>$filename</hl> variable. (At least when the code is not in a subroutine.)

Then we basically have the following code:
<hl>$filename or die "Usage: $0 FILENAME\n"</hl>

This is a <a href="/boolean-values-in-perl">boolean</a> expression.
If the <hl>$filename</hl> contains the name of a file
then it will be <a href="/boolean-values-in-perl">considered True</a> and the script will go
on running without executing the <hl>or die ...</hl> part.
On the other hand, if the @ARGV was empty, <hl>$filename</hl> was assigned <hl>undef</hl>,
and it will <a href="/boolean-values-in-perl">count as False</a>
and Perl will execute the right-hand-side of the <hl>or</hl>statement,
printing a message to the screen and exiting the script. 

So effectively, this piece of code would check if a value was provided on the command line. The value
is copied to <hl>$filename</hl>. If there was no value, the script would <hl>die</hl>.

<h2>Minor bug</h2>

There is one minor bug in the above code. If the user supplies 0 as the name of the file. It will still
be seen as False and the script will refuse to handle such a file. The question though: Does it matter?
Can we live with the fact that our script might not handle a file called <b>0</b>... ?

<h2>Complex cases</h2>

There are a lot of other cases that are much more complex than the above one or two parameter cases.
For those cases you'd probably want to use a tool such as <hl>Getopt::Long</hl> that will be able to analyze
the content of <hl>@ARGV</hl> based on some declaration of what kind of parameters you'd want to accept.




=title How to sort a hash in Perl?
=timestamp 2013-08-30T16:30:01
=indexes hash, keys, values, sort, cmp, <=>, $a, $b
=status show
=books beginner
=author szabgab
=comments_disqus_enable 1

=abstract start

This question comes up often, and every time it might hide something interesting behind it.

One of the important features of a hash, or hashmap, or dictionary,
or associative array as some other languages
like to call it, is that it is a set of <b>unsorted</b> key-value pairs.

So when someone asks <b>how to sort a hash?</b>, the reaction usually is that you <b>cannot sort a hash</b>.
The other reaction might be pointing people to tool that can handle a <a href="/sorted-hash-tie-ixhash">sorted hash</a>
even though that has a significant run-time penalty.

So what do people really mean when they want to <b>sort a hash?</b>

=abstract end

<h2>How to sort a hash?</h2>

For example let's say we have a hash with the names of the planets in our
<a href="http://en.wikipedia.org/wiki/Solar_System">Solar system</a> and with their
average distance from the Sun as measured in
<a href="http://en.wikipedia.org/wiki/Astronomical_unit">Astronomical units</a>.

Reading those pages actually revealed that Pluto is not considered a planet on its own
any more, but as a <a href="http://en.wikipedia.org/wiki/Dwarf_planet">dwarf planet</a>
which is part of the <a href="http://en.wikipedia.org/wiki/Kuiper_belt">Kuiper belt</a>.
There is also <a href="http://en.wikipedia.org/wiki/Charon_(moon)">Charon</a> which is
sometimes considered to be a moon of Pluto, sometimes as part of a
<a href="http://en.wikipedia.org/wiki/Binary_system_(astronomy)">binary system</a>.
It will be useful for our purposes, so I added it to the hash.

Anyway, we create the hash, fill it with values and the print it out using a <hl>foreach</hl>
loop on the planet names returned by the <hl>keys</hl> function.

<include file="examples/sort_a_hash.pl">

The output looks like this:
<code>
Jupiter  5.2
Uranus   19.6
Ceres    2.77
Saturn   9.5
Earth    1
Neptune  30
Charon   39
Mars     1.5
Venus    0.7
Mercury  0.4
Pluto    39
</code>

Not only is it in a seemingly random order, depending on our version of Perl it can
be in different order as well. Even if in older versions of Perl this order seemed to be
stable between runs, starting from 5.18.0, even that is very unlikely.

<h2>Sort the hash in alphabetical order of its keys</h2>

When someone wants to <b>sort a hash</b>, one possibility is that he wants to sort
the planets in alphabetical order. That's quite easy.

<code lang="perl">
foreach my $name (sort keys %planets) {
    printf "%-8s %s\n", $name, $planets{$name};
}
</code>

The output is always going to be:

<code>
Ceres    2.77
Charon   39
Earth    1
Jupiter  5.2
Mars     1.5
Mercury  0.4
Neptune  30
Pluto    39
Saturn   9.5
Uranus   19.6
Venus    0.7
</code>

But that's not exactly alphabetical sorting. The default behavior of <hl>sort</hl>
is to sort based on the ASCII table. (Except when <hl>use locale</hl> is in effect,
but we don't want to go there now.)
This means that the default sorting would put all the upper-case letters in front of all
the lower-case letters. If we really want to have alphabetical sorting we can do the following:

<code lang="perl">
foreach my $name (sort {lc $a cmp lc $b} keys %planets) {
    printf "%-8s %s\n", $name, $planets{$name};
}
</code>

That's OK, but what if what we want is to <b>sort the values of the hash</b>?

<h2>Sort the values of the hash</h2>

That's another thing that can be easily misunderstood. If we take that request literally
we will write the following code:

<code lang="perl">
foreach my $distance (sort values %planets) {
    say $distance;
}
</code>

gaining the following output:

<code>
0.4
0.7
1
1.5
19.6
2.77
30
39
39
5.2
9.5
</code>

That is, we fetch the <hl>values</hl> of the hash, and sort them based on the ASCII table.

Maybe we are kind and notice the values are numbers and 2.77 should not fall between 19.6 and 30,
and sort them according to their numerical value like this:

<code lang="perl">
foreach my $distance (sort {$a <=> $b} values %planets) {
    say $distance;
}
</code>

<code>
0.4
0.7
1
1.5
2.77
5.2
9.5
19.6
30
39
39
</code>

But ultimately someone will ask us: <b>OK, but how can I get back the names of the planets from the values?</b> 
And you can't. For one the mapping of the hash is one-directional: from key to value, but maybe
more importantly, the values are not required to be unique. In our example, both Pluto and Charon
are at the same average distance from the Sun.

What is more likely is that we wanted to <b>Sort the names of the planets according to their distance form the Sun</b>.
In more general wording:

<h2>Sort the keys of the hash according to the values</h2> 

We almost always want to sort the keys of the hash.
Sometimes based on a property of the keys and sometimes
based on a property of the values in the hash.

<code lang="perl">
foreach my $name (sort { $planets{$a} <=> $planets{$b} } keys %planets) {
    printf "%-8s %s\n", $name, $planets{$name};
}
</code>

Here <hl>$a</hl> and <hl>$b</hl>, the place-holder variables of <hl>sort</hl>
will always hold two keys returned by the <hl>keys</hl> function and
we compare the respective values using the <hl>spaceship operator</hl>.

If some of these sorting functions look strange,
please take a look at the article on <a href="/sorting-arrays-in-perl">sorting arrays and lists</a>.
The explanations there might make more sense.

Anyway, the output will be sorted exactly as we wanted:

<code>
Mercury  0.4
Venus    0.7
Earth    1
Mars     1.5
Ceres    2.77
Jupiter  5.2
Saturn   9.5
Uranus   19.6
Neptune  30
Pluto    39
Charon   39
</code>

Well, almost exactly. If we run that code repeatedly we will notice
that Pluto and Charon are swapping places. Just in the reality, out there
in the cold of the Kuiper belt.

That's because they have the same value, so our comparison function cannot
decide which is closer to the Sun.

In some cases this is OK, in other cases we will want to make sure keys
that have the same value will be sorted according the ASCII table. For that
case we have the following code:


<code lang="perl">
foreach my $name (sort { $planets{$a} <=> $planets{$b} or $a cmp $b } keys %planets) {
    printf "%-8s %s\n", $name, $planets{$name};
}
</code>

With this code Charon will always come before Pluto as they have the same distance from the
Sun, but C comes before P in the ASCII table.


=title Writing to files with Perl
=timestamp 2012-12-20T16:45:56
=indexes open, close, write, die, open or die, >, encoding, UTF-8
=status show
=books beginner_book
=author szabgab
=index 1
=archive 1
=feed 1
=comments 1
=social 1

=abstract start

很多Perl程序是用来处理文本文件，例如配置文件或者日志文件, 所以为了让我们的知识可以用起来，一开始就学习文件处理是很重要的.

首先来看一下怎么写文件（因为这很简单）.

=abstract end

在你能够写文件之前，你需要<b>打开</b>它, 让操作系统(Windows, Linux, OSX, 等)给你的程序开启一个与文件“对话”的通道.
为了这样的需求, Perl提供了一个语法有点奇怪的<hl>open</hl>函数.

<code lang="perl">
use strict;
use warnings;

my $filename = 'report.txt';
open(my $fh, '>', $filename) or die "Could not open file '$filename' $!";
print $fh "My first report generated by perl\n";
close $fh;
print "done\n";
</code>

这是一个很好的例子，我们后来会用到它，而现在先看一个更简单的例子:

<h2>简单示例</h2>

<code lang="perl">
use strict;
use warnings;

open(my $fh, '>', 'report.txt');
print $fh "My first report generated by perl\n";
close $fh;
print "done\n";
</code>

需要简单解释一下. The <b>open</b> 函数可以接受3个参数.

第一个, <hl>$fh</hl>, 是一个在<hl>open()</hl>调用中定义的标量.
我们也可以在之前就定义它, 但是在函数中定义会更清晰一些(开始的时候会有些别扭),
第二个参数定义了我们打开文件的方式. 本例中, 大于号(<hl>&gt;</hl>) 表示打开文件是为了写操作.
第三个参数是要打开的文件的路径.

当调用这个函数的时候，它在<hl>$fh</hl>变量中设定了一特殊的记号, 称为文件句柄. 
我们并不关心这个变量的内容，仅仅在后面使用它.
只需记住, 文件的内容仍然在磁盘上, <b>并不</b> 在$fh变量中.

一旦打开了文件我们就可以在<hl>perl()</hl>的语句总使用文件句柄<hl>$fh</hl>.
它看起来跟文档其他部分的<hl>print()</hl>很像,
但是这里第一个参数是文件句柄, 并且后面<b>没有</b>(!)逗号.

上面的print()会在文件里写入文本.

后一行关闭了文件句柄. 严格来说这在Perl并不是必须的. 
Perl会在这个变量超出作用域的时候自动并且适当的关闭所有的文件句柄.(至少在脚本的最后是这么做的)
无论如何, 显式地关闭文件是一种很好的实践习惯.

最后一行<hl>print "done\n"</hl>是为了让下个例子更加清晰:

<h2>错误处理</h2>

我们可以再次举上边的例子，但是这次使用一个不存在的文件路径.
例如这样写:

<code lang="perl">
open(my $fh, '>', 'some_strange_name/report.txt');
</code>

如果现在执行脚本，你会看到这样的错误信息:

<code>
print() on closed file-handle $fh at ...
done
</code>

事实上，这只是一个警告; 脚本会继续执行，这也是我们在屏幕上看到"done"被打印出来的原因.

进一步来说, 只有在显式地使用<hl>use warnings</hl>语句的时候才会有警告信息.
你可以尝试一下注释掉<hl>use warnings</hl>, 来验证创建文件失败的时候，脚本现在是保持安静的.(不会提示警告信息)
这样的话在用户或者老板抱怨之前你都不会注意到它.

不过这仍是一个问题. 我们尝试着去打开文件，尽管失败了，但是仍然想要往里print()数据.

我们最好在进一步处理之前先检查一下<hl>open()</hl>是否成功.

幸运的是, <hl>open()</hl> 的函数调用本身会返回
<a href="http://perl5maven.com/boolean-values-in-perl">TRUE(成功), FALSE(失败) </a>, 所以我们可以这么写:

<h2>Open or die</h2>

<code lang="perl">
open(my $fh, '>', 'some_strange_name/report.txt') or die;
</code>

这是标准的<b>open or die</b>习语. 在Perl中很常见.

<hl>die</hl> 是一个函数调用，它会抛出一个异常并停止执行脚本.

"open or die" 是一个逻辑表达式. 正如你从教程的前半部分看到的那样, 
"or" 在Perl中是短路执行的(就像在其它编程语言中那样).
这意味着，如果左半部分是TRUE, 我们就能知道整个表达式是TRUE, 
并且右半部分是不执行的. 另一方面，如果左半部分是FALSE, 
那么右半部分会执行，而且它的结果就是整个表达式的结果.

在本例中，我们使用短路特性来写表达式.

如果<hl>open()</hl>成功执行, 返回TRUE, 那么右边部分不会执行. 脚本会到下一行.

如果<hl>open()</hl>执行失败, 返回FALSE. 那么<hl>or</hl>右边部分会执行. 它会抛出异常并退出脚本.

在上边的例子中我们不检查逻辑表达式实际的返回值.
我们并不关心，只是使用它的"副作用".

如果你尝试执行上面更改的脚本，会得到错误信息:

<code>
Died at ...
</code>

并不会打印"done".

<h2>更好的错误报告</h2>

除了不加参数的调用die以外，我们也可以附加一些说明.

<code lang="perl">
open(my $fh, '>', 'some_strange_name/report.txt')
  or die "Could not open file 'some_strange_name/report.txt'";
</code>

将会输出

<code>
  Could not open file 'some_strange_name/report.txt' ...
</code>

这会好一些，但是有时候某些人会尝试把文件的路径修改正确 ...
<code lang="perl">
open(my $fh, '>', 'correct_directory_with_typo/report.txt')
  or die "Could not open file 'some_strange_name/report.txt'";
</code>

...但是你得到的仍然还是原来的错误信息，因为他们只是在open()调用中进行了修改，却忘了修改错误信息.

用一个变量来代替文件名，可能会更好一些：

<code lang="perl">
my $filename = 'correct_directory_with_typo/report.txt';
open(my $fh, '>', $filename) or die "Could not open file '$filename'";
</code>

现在我们能获得正确的错误信息，但是仍然不知道为什么会失败.
为了更近一步，我们可以使用<hl>$!</hl>(Perl的内置变量)来打印出操作系统的错误提示：

<code lang="perl">
my $filename = 'correct_directory_with_typo/report.txt';
open(my $fh, '>', $filename) or die "Could not open file '$filename' $!";
</code>

这样会输出

<code>
Could not open file 'some_strange_name/report.txt' No such file or directory ...
</code>

好多了吧.

现在我们可以回到最初的例子.

<h2>大于?</h2>

调用open时使用的大于号可能有点不清晰，但是如果你熟悉命令行的重定向，那么这应该对你不成问题.
否则的话，可以把它想象成指示数据流方向(流向右侧的文件)的箭头.

<h2>非拉丁字符?</h2>

在需要处理非ASCII字符的情况下, 你可能想要使用UTF-8来存储它们. 
这样的话，你需要告诉Perl，你正在使用UTF-8编码打开文件.

<code lang="perl">
open(my $fh, '>:encoding(UTF-8)', $filename)
  or die "Could not open file '$filename'";
</code>



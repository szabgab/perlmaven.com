=title סאב-רוטינות(שיגרות) ופונקציות בפרל
=timestamp 2013-11-27T19:00:00
=indexes sub, return, subroutine, function, @_, $_[0]
=status show
=original subroutines-and-functions-in-perl
=books beginner
=author szabgab
=translator bruck
=comments_disqus_enable 0

=abstract start

הדרך הפשוטה ביותר לשימוש חוזר בקוד היא יצירת סאב-רוטינות (שיגרה - subroutine).

סאב-רוטינות מאפשרות להריץ את אותו קוד במספר מקומות ביישום שלכם, והן מאפשרות להריץ אותו עם פרמטרים שונים.

=abstract end

בחלק משפות התיכנות יש אבחנה בין פונקציות לסאב-רוטינות.
בפרל אין הבדל ביניהן. יוצרים את הפונקציה (סאב-רוטינה) באמצעות מילת המפתח <hl>sub</hl> ,
והיא תמיד מחזירה ערך. מתכנתי פרל לרוב משתמשים במושגים
<b>פונקציה</b> ו <b>סאברוטינה</b> כמושגים נרדפים.

<h2>פונקציה פשוטה</h2>

למשל נניח שאתם רוצים לפנות אל המשתמש ולשאול שאלה:

<code lang="perl">
ask_question();
my $answer = get_answer();
# some code
ask_question();
my $second_answer = get_answer();

########## sub declarations come here

sub ask_question {
  print "Have we arrived already?";
  return;
}

sub get_answer {
  my $answer = <STDIN>;
  chomp $answer;
  return $answer;
}

sub terminate {
   die "Hasta La Vista";
}
</code>

בחלק הראשון של הקוד קראנו פעמיים לפונקציה  <hl>ask_question</hl> ,
וכמו כן קראנו לפונקציה <hl>get_answer</hl> פעמיים. בחלק השני של הקוד, אחרי ה-
 #####, יש לנו את את ההגדרות של שלוש הפונקציות.

הפונקציה הראשונה היא מאוד פשוטה. היא מדפיסה למסך מחרוזת קבועה, ואז לא מחזירה כלום.

השנייה משלבת את אופרטור קריאת השורה ואת  <hl>chomp</hl> לקריאה אחת לפונקציה.
היא ממתינה לקלט, וכשנלחץ ENTER היא מחזירה את המחרוזת שהקלדתם ללא סימן סוף השורה (newline) בסופה.

הפונקציה השלישית גם היא מאוד פשוטה, אך אף פעם לא קוראים לה ולכן היא אינה מבוצעת. זוהי נקודה מאוד חשובה למי שאינו מכיר פונקציות וסאב-רוטינות. הקוד שלכם, לא משנה איפה הוא נמצא בקובץ - מבוצע רק כשהוא  "<b>נקרא</b>" על ידי שימוש בשם הפונקציה.
בדיוק כפי שקראנו לשתי הפונקציות האחרות.


בכל המקרים, פרט למקרה האחרון, קראנו לפונקציה <hl>return</hl> של פרל כדי להחזיר ערך. למעשה הפונקציה תחזיר ערך כלשהו אפילו אם לא קראנו במפורש ל- <hl>return</hl>, אך מאוד מומלץ תמיד לקרוא ל-
<hl>return</hl>. אפילו אם אין לנו משהו מיוחד להחזיר כמו בפונקציה <hl>ask_question()</hl> .

<h2> - בקשה לקלט prompt</h2>

נראה שיהיה יותר מעניין לשלב את שתי הפונקציות. כך תוכלו לכתוב:

<code lang="perl">
my $answer = prompt();
# some code
my $second_answer = prompt();

sub prompt {
   print "Have we arrived already?";

   my $answer = <STDIN>;
   chomp $answer;
   return $answer;
}
</code>

כמובן שייתכן שתירצו שבכל אחד מהמקרים הפונקציה  <hl>prompt()</hl> תציג טקסט שונה.
 ודאי תירצו אפשרות לקבוע את הטקסט שיוצג כשאתם קוראים לפונקציה<hl>prompt()</hl>. משהו שנראה כך:

<code lang="perl">
my $first_name = prompt("First name: ");
my $last_name = prompt("Last name: ");

sub prompt {
   my ($text) = @_;
   print $text;

   my $answer = <STDIN>;
   chomp $answer;
   return $answer;
}
</code>

בדוגמה זו קראנו פעמיים לפונקציה prompt() .
בכל אחת מהקריאות העברנו מחרוזת שהיא הטקסט של השאלה שאנחנו שואלים. המחרוזת הודפסה. התגובה נקלטה על ידי הפונקציה והוחזרה לקוד שקרא לפונקציה.

החידוש בדוגמה זו הייתה הצורה שבה העברנו את הפרמטר.
אפילו יותר מעניין לראות איך הפונקציה קיבלה אותו.

כשקרואים לפונקציה אפשר להעביר לה מספר שרירותי של ארגומנטים, והערכים יוכנסו למשתנה הפנימי <hl>@_</hl> . המשתנה שייך לפוקנציה שבה הוא נמצא. לכל פונקציה יש משתנה  <hl>@_</hl> משלה.
ניתן לגשת לאלמנטים שלו כמו שעושים עם כל מערך אחר, כאשר <hl>$_[0]</hl>
הוא האלמנט הראשון, אבל זה לא נראה יפה.

לרוב עדיף להעתיק את הערכים של  <hl>@_</hl> על ידי הצבתם ברשימה של ערכים מקומיים לפונקציה. זה מה שעשינו בדוגמה לעיל האחרונה עם 
 <hl>my ($text) = @_;</hl>.

אחת השגיאות הנפוצות היא לשכוח את הסוגריים בהצבה.

<code lang="perl">
sub prompt {
   my $text = @_;    # BAD! זה לא מה שאתם רוצים!!!
   ...
}
</code>

מה שיקרה זה שהמערך ייקרא בהקשר סקלרי ויחזיר את מספר האלמנטים. כך תקבלו מספר במשתנה  $text .
אם לא ברור לכם הנושא של הקשר, אפשר לקרוא על זה עוד 
<a href="/scalar-and-list-context-in-perl">הקשר סקלרי(Scalar) והקשר רשימתי (List) בפרל</a>
ואחר כך לחזור לכאן.

<h2>Prototypes אב-טיפוס</h2>

חלק משפות התיכנות מאפשרות, ואפילו מחייבות ליצור  "prototypes (אב-טיפוס)" לפני שיוצרים את הפונקציה עצמה.

בפרל אין בכך צורך.

למעשה יש משהו בפרל שנקראה פרוטוטיפ, אבל זה לא עובד כמו שהייתם מצפים שזה יעבוד, ואני לא ממליץ עליהם.
ודאי לא למתחילים.
פרוטוטייפים בפרל הם שימושיים רק במקרים מעטים

<h2>פרמטרים או חתימה</h2>

בפרל 5 אין צורך או אפשרות להצהיר על  ה<b>חתימה</b> של פונקציה. 

כלומר, אי אפשר להצהיר על רשימת הפרמטרים המבוקשים. המשמעות של זה היא שגם אין שום בדיקה של הפרמטרים מצד פרל.
ב-CPAN יש מספר מודולים שעוזרים ליצור משהו שדומה לחתימה.
ייתכן שתירצו לנסות אותם.

<code lang="perl">
sub do_something() {    # BAD !
}
</code>

אין לכתוב סוגריים אחרי שם הפונציה כשמגדירים אותה! עם זאת, אפשר להשתמש בסוגריים כשקוראים לפונקציה:

<h2>סוגריים</h2>

השימוש בסוגריים <hl>()</hl> כשקוראים לה אינו חובה אם הפונקציה כבר הוגדרה, ואם הכוונה ברורה..
אם אתם טוענים מודול באמצעות <hl>use</hl> והיא מייבאת פונקציה, תוכלו להשתמש בה בקוד שלכם בלי סוגריים.

מצד שני, אם אתם שמים את הגדרות הפונקציות שלכם בסוף הקוד - ואני ממליץ לכם לעשות כך - אז תצטרכו להשתמש בסוגריים כשאתם קוראים לפונקציה.

<h2>ערכים מוחזרים</h2>

פונקציות בפרל תמיד מחזירות ערך.

או במפורש על ידי קריאה ל- <hl>return</hl>, או את התוצאה של השורה האחרונה בפונקציה.
מומלץ תמיד לקרוא במפורש ל-<hl>return</hl>.

יש אפילו מדיניות של  <a href="http://perlcritic.com/">Perl::Critic</a> שבודקת את הקוד שלכם ומציינת כל פונקציה שאין לה קריאה מפורשת ל-return בסוף הגדרת הפונקציה.

אם אין מה להחזיר אז פשוט קוראים ל- <hl>return;</hl> בלי ארגומנטים.
כך אתם מוודאים שאתם באמת לא מחזירים כלום, במקום להחזיר בטעות את התוצאה של השורה האחרונה. זו דרך טובה להמנע מהפתעות למי שמשתמש בפונקציה.



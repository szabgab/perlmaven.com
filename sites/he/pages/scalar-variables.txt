=title משתנים סקלריים
=timestamp 2013-07-21T12:00:00
=indexes strict, my, undef, say, +, x, ., sigil, $, @, %, FATAL warnings
=status show
=original scalar-variables
=books beginner
=author szabgab
=translator bruck
=comments_disqus_enable 0

=abstract start

בחלק זה של  <a href="/perl-tutorial">המדריך לפרל</a>, נסתכל על מבני הנתונים הקיימים בפרל ועל השימוש בהם.

בפרל 5 יש שלושה מבני נתונים. <b>סקלרים, מערכים והאש (Hash)</b>. האש ידועים גם כמערכים אסוציאטיביים, או מילונים בשפות אחרות

=abstract end

משתנים בפרל תמיד נכתבים עם סימן מזהה בתחילתם המכונה  <b>סיג'יל (sigil)</b>. הסימנים הם <עבור משתנים סקלרים ,
<hl>@</hl> עבור מערכים ו- <hl>%</hl> עבור האש.

סקלר יכול להכיל ערך בודד כגון מספר או מחרוזת כמו כן הוא יכול להכיל הפנייה למבנה נתונים אחר - נראה זאת בהמשך.

שם של משתנה סקלרי תמיד מתחיל עם  <hl>$</hl> (סימן דולר) ואחריו אותיות, מספרים וקווים תחתיים.
שם משתנה יכול להיות <hl>$name</hl> או <hl>$long_and_descriptive_name</hl>. הוא יכול להיות גם
<hl>$LongAndDescriptiveName</hl> זו צורה שמכונה לרוב "CamelCase",
אך קהילת הפרל מעדיפה לרוב שמות משתנים כתובים באותיות קטנות כאשר קווים תחתיים מפרידים בין המילים בשם המשתנה.

כיון שאנחנו תמיד משתמשים ב- <b>strict</b>, ראשית עלינו להכריז על המשתנים באמצעות  <b>my</b>.
(בהמשך תלמדו גם על  <b>our</b> ועל אפשרויות נוספות, אך לעת עתה נשאר עם ההכרזה באמצעות <b>my</b> .)
ניתן גם מייד עם ההכרזה להציב ערך כמו בדוגמה הבאה:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $name = "Foo";
say $name;
</code>

אפשר גם להכריז על המשתנה ולהציב בו ערך מאוחר יותר:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $name;

$name = "Foo";
say $name;
</code>

אנחנו מעדיפים את הצורה הראשונה אם הלוגיקה של הקוד מאפשרת זאת.

אם הכרזנו על משתמש אך טרם הצבנו בו ערך אז יהיה לו ערך שנקרא <a href="https://perlmaven.com/undef-and-defined-in-perl">undef</a> ערך זה דומה ל- <b>NULL</b> in databases,
אבל יש לו התנהגות קצת שונה.

ניתן לבדוק אם משתנה הוא <hl>undef</hl> באמצעות הפונקציה <hl>defined</hl> :

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $name;

if (defined $name) {
  say 'defined';
} else {
  say 'NOT defined';
}

$name = "Foo";

if (defined $name) {
  say 'defined';
} else {
  say 'NOT defined';
}

say $name;
</code>

ניתן להפוך משתנה סקלרי ל- <hl>undef</hl> על ידי הצבת  <hl>undef</hl> במשתנה:

<code lang="perl">
$name = undef;
</code>

המשתנים הסקלרים יכולים להכיל או מספרים או מחרוזות. לכן אפשר לכתוב:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $x = "hi";
say $x;

$x = 42;
say $x;
</code>

וזה פשוט עובד.

איך זה עובד יחד עם אופרטורים והעמסת אופרטורים בפרל?

כללית פרל עובדת הפוך מרוב השפות האחרות במקום שהאופרנדים, הערכים, יגידו לאופרטורים, לפעולות, כיצד להתנהג, האופרטורים אומרים לאופרנדים כיצד להתנהג.

כך ש אם יש לי שני משתנים שמכילים מספרים  אז האופרטור מחליט אם הם באמת צריכים להתנהג כמו מספרים או כמו מחרוזות.

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 2;
say $z;             # 2
my $y = 4;
say $y;             # 4

say $z + $y;        # 6
say $z . $y;        # 24
say $z x $y;        # 2222
</code>

<hl>+</hl>,הוא אופרטור חיבור המספרים, מחבר שני מספרים, לכן  <hl>$y</hl> ו- <hl>$z</hl> מתנהגים כמו מספרים.

<hl>.</hl>, משרשר שתי מחרוזות לכן <hl>$y</hl> ו- <hl>$z</hl> מתנהגים כמו מחרוזות. (בשפות אחרות ייתכון שתקראו לפעולה זו חיבור מחרוזות.)

<hl>x</hl>, אופרטור החזרה, חוזר על המחרוזת בצד השמאלי מספר פעמים שווה למספר בצד הימני,
לכן במקרה זה <hl>$z</hl> מתנהג כמחרוזת ואילו <hl>$y</hl> מתנהג כמספר.

התוצאות היו זהות אם שניהם היו נוצרים כמחרוזות:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = "2";
say $z;             # 2
my $y = "4";
say $y;             # 4

say $z + $y;        # 6
say $z . $y;        # 24
say $z x $y;        # 2222
</code>

ואפילו אם אחד מהם היה נוצר כמספר והשני כמחרוזת:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 7;
say $z;             # 7
my $y = "4";
say $y;             # 4

say $z + $y;        # 11
say $z . $y;        # 74
say $z x $y;        # 7777
</code>

פרל ממירה אוטומטית מספרים למחרוזות ומחרוזות למספרים על פי דרישות האופרטור.

מכנים אותם  <b>הקשרים (contexts)</b>  הקשר מספרי (נומרי) והקשר מחרוזת.

המקרים הקודמים היו קלים כשממירים מספר למחרוזת זה כמו לשים גרשיים מסביב למספר כשממירים מחרוזת למספר, יש מקרים פשוטים, כמו המקרים שראינו, שבהם המחרוזת מורכבת אך ורק ממספרים אותו דבר היה קורה אם הייתה נקודה עשרונית במחרוזת, למשל <hl>"3.14"</hl>.
השאלה היא, מה קורה אם המחרוזת מכילה תווים שאינם חלק משום מספר למשל <hl>"3.14 הוא פאי"</hl>.
איך תתנהג המחרוזת עם אופרטור נומרי (כלומר, בהקשר נומרי)? 

גם מקרה זה פשוט, אך הוא דורש הסבר

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 2;
say $z;             # 2
my $y = "3.14 is pi";
say $y;             # 3.14 is pi

say $z + $y;        # 5.14
say $z . $y;        # 23.14 is pi
say $z x $y;        # 222
</code>

כשמחרוזת נמצאת בהקשר נומרי, פרל מסתכלת בצד השמאלי של המחרוזת ומנסה להמיר אותו למספרים. כל זמן שהגיוני לבצע את ההמרה, חלק זה הופך לחלק הנומרי של המשתנה. בהקשר נומרי (<hl>+</hl>) המחרוזת
<hl>"3.14 הוא פאי"</hl> נחשבת למספר <hl>3.14</hl>.

מבחינה מסוימת זו החלטה שרירותית לגמרי, אבל כך זה עובד, אז עם זה אנחנו מסתדרים.

הקוד הנ"ל גם ייצור התרעה בערוץ השגיאה הסטנדרטי (<hl>STDERR</hl>):

<code>
Argument "3.14 is pi" isn't numeric in addition(+) at example.pl line 10.
</code>

בהנחה שהשתמשתם ב- <b>use warnings</b> כפי שמאוד מומלץ לעשות.
השימוש בהתרעות יעזור לכם לשים לב כשמשהו מתנהג לא בדיוק כפי שציפיתם.
אני מקווה שהתוצאה של  <hl>$x + $y</hl> נראית עכשיו ברורה יותר.

<h2>רקע</h2>

שימו לב גם שפרל לא שינתה את הערך של <hl>$y</hl> ל- 3.14. היא רק השתמשה בערך הנומרי בפעולת החיבור.
זה וודאי מסביר גם את התוצאה של <hl>$z . $y</hl>l.
במקרה זה פרל משתמשת בערך המקורי של המחרוזת.

ייתכן שתשאלו למה <hl>$z x $y</hl> מראה 222 בעוד שהיה לנו 3.14 מצד ימין,
נראה שפרל יודעת לחזור על מחרוזות רק מספר פעמים שלם... Iפרל מעגלת את המספר מצד ימין בלי לתת התרעה על כך. (אם אתם באמת רוצים לחשוב על זה לעומק, אז תיראו שההקשר "המספר" שהוזכר קודם הוא למעשה הקשר עם מספר תת-הקשרים, אחד מהם הוא "מספר שלם". לרוב פרל עושה מה "שנראה נכון" לרוב האנשים שאינם מתכנתים.)

בנוסף לכך, אנחנו אפילו לא רואים התרעה על המרה של חלק ממחרוזת למספר "partial string to number" כפי שראינו במקרה של<hl>+</hl>.

 הסיבה היא לא האופרטור השונה. אם נשים את השורה עם פעולתהחיבור בהערה אז נראה את ההתרעה על הפעולה הסיבה להעדרה של הפעולה השנייה היא שכשפרל ייצרה את הערך המספרי של המחרוזת <hl>"3.14 is pi"</hl> it
היא גם שמרה אותו בכיס מוסתר של המשתנה <hl>$y</hl> . כך שבעצם <hl>$y</hl>
מחזיק עכשיו גם את ערך המחרוזת וגם את הערך המספרי, והערך הנכון ישמש בכל פעולה חדשה ועל ידי יימנע הצורך מהמרה נוספת.

ברצוני לציין שלושה דברים נוספים. אחד הוא ההתנהגות של משתנה עם הערך
<hl>undef</hl> , השני הוא  <b>התרעות פטליות - (fatal warnings)</b> והשלישי הוא המנעות מהמרה "אוטומטית" ממחרוזת למספר.

<h2>undef</h2>

אם ערכו של משתנה הוא  <hl>undef</hl> משהו שאליו רוב האנשים ייתחסו כאל "כלום" , עדיין אפשר להשתמש בו.
בהקשר נומרי הוא יתנהג כמו 0 בהקשר מחרוזת הוא ייתנהג כמו המחרוזת הריקה:

<code lang="perl">
use strict;
use warnings;
use 5.010;

my $z = 3;
say $z;        # 3
my $y;

say $z + $y;   # 3
say $z . $y;   # 3

if (defined $y) {
  say "defined";
} else {
  say "NOT";          # NOT
}
</code>

עם שתי התרעות:

<code>
Use of uninitialized value $y in addition (+) at example.pl line 9.

Use of uninitialized value $y in concatenation (.) or string at example.pl line 10.
</code>

כפי שניתן לרואים ערכן של המשתנה בסוף הוא עדיין<hl>undef</hl> ולכן התוצאה של משפט התנאי תהיה הדפסת "NOT".


<h2>התרעות פטליות - Fatal warnings</h2>

הנושא השני הוא שיש אנשים שמעדיפים שהתוכנית תזרוק חריגה (exception) קשה במקום התרעה הרכה. אם זו ההעדפה שלכם, אתם יכולים לשנות את תחילת הקוד ולכתוב

<code lang="perl">
use warnings FATAL => "all";
</code>

כששורה זו נמצאת בקוד, התוכנית תדפיס את המספר 3, ואז תזרוק חריגה

<code>
Use of uninitialized value $y in addition (+) at example.pl line 9.
</code>

זו אותה הודעה שהתקבלה קודם כהתרעה, אבל במקרה זה התוכנית מפסיקה לרוץ.
(אלא אם תופסים את החריגה, אבל זה נושא לדיון נפרד)

<h2>המנעות מהמרה אוטומטית של מחרוזות למספרים</h2>

אם תירצו להמנע מהמרה אוטומטית של מחרוזות כשאין המרה מדוייקת, תוכלו לבדוק אם המחרוזת נראית כמו מספר כשאתם מקבלים אותה מהעולם החיצון.

כדי לעשות זאת נשתמש במודול <a href="https://metacpan.org/pod/Scalar::Util">Scalar::Util</a>,
ונשתמש בפונקציה שלה <hl>looks_like_number</hl> .

<code lang="perl">
use strict;
use warnings FATAL => "all";
use 5.010;

use Scalar::Util qw(looks_like_number);

my $z = 3;
say $z;
my $y = "3.14";

if (looks_like_number($z) and looks_like_number($y)) {
  say $z + $y;
}

say $z . $y;

if (defined $y) {
  say "defined";
} else {
  say "NOT";
}
</code>


<h2>העמסת אופרטורים (operator overloading)</h2>

בנוסף לכל האמור, תמיד תוכלו ליישם העמסת אופרטורים ובמקה זה הערכים (אופרנדים) יכתיבו לאופרטורים מה לעשות. נשאיר את זה לדיון סיום מתקדם יותר.



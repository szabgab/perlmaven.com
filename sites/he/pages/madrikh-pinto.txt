=title Pinto -- פינטו
=timestamp 2013-05-04T08:00:00
=indexes cpan, pinto
=status show
=original pinto-tutorial
=author thalhammer
=translator bruck
=comments_disqus_enable 0

=abstract start

<i>
רשומה זו היא רשומת אורח מאת <href="http://twitter.com/thaljef">Jeffrey Ryan Thalhammer ג'פרי רייאן תאלהמר</a>
המפתח של פינטו (Pinto) ושל Perl::Critic. ג'ף מנהל עסק קטן לייעוץ בסן פרנסיסקו והוא פעיל בקהילת הפרל במשך שנים רבות.
ג'ף מנסה  <a href="https://www.crowdtilt.com/campaigns/specify-module-version-ranges-in-pint">לגייס כעת מימון</a> לפיתוח היכולות שיאפשרו לציין טווחים של מספרי גירסאות בפינטו.
</i>

אחת המעלות הבולטות של פרל היא כל המודולים בקוד פתוח שניתן למצוא על CPAN.
אך בכלל לא קל להתעדכן בכל החידושים והעדכונים. בכל שבוע מופצים מאות עידכונים חדשים
ואי אפשר לדעת באיזו גירסה של מודול יופיע פתאום באג חדש שיפיל את היישום שלך.


=abstract end

אחד הפתרונות האפשריים לבעיה זו היא ליצור מאגר CPAN משלך המכיל רק את גרסאות המודולים הרצויות לך.
תוכל להשתמש בכלי CPAN לבניית היישום שלך מהמודולים שנמצאים במאגר שלך, שהותאם לצרכיך,
בלי לחשוף את עצמך לכל הפעלתנות של המאגר הציבורי של CPAN.

במשך השנים בניתי מספר מאגרי CPAN מותאמים אישית באמצעות כלים כמו 
<a href="https://metacpan.org/pod/CPAN::Mini">CPAN::Mini</a>
ו-<a href="https://metacpan.org/pod/CPAN::Site">CPAN::Site</a>.
אך הם תמיד נראו מגושמים ולא ממש הייתי מאושר איתם. לפני מספר שנים, לקוח שכר אותו 
לפתח עוד מערכת CPAN מותאמת ללקוח. אך הפעם הייתה לי הזדמנות להתחיל מאפס. 
פינטו (Pinto) הוא התוצאה של אותו פרוייקט.


<a href="https://metacpan.org/pod/Pinto">פינטו</a> הוא כלי עתיר יכולות
להקמת מאגר CPAN ולניהולו.
יש לו מספר תכונות רבות עוצמה שמסייעות לנהל
 בביטחה את כל מודולי הפרל הנחוצים ליישום שלך.
מדריך זה יראה כיצד ליצור מאגר CPAN מותאם אישים באמצעות פינטו וידגים חלק מהיכולות של פינטו.


<h2>התקנת פינטו</h2>

פינטו זמין ב-CPAN וניתן להתקינו כמו כל מודול אחר באמצעות הכלי cpan או <hl>cpanm</hl>.
פינטו דומה יותר ליישום מאשר לספרייה. הוא כלי שמאפשר לך לנהל את קוד היישום שלך, 
אך הוא לא חלק מהיישום. 
לכן אני ממליץ להתקין את פינטו כיישום בפני עצמו  באמצעות הפקודות הבאות:

<code>
curl -L http://getpinto.stratopan.com | bash
source ~/opt/local/pinto/etc/bashrc
</code>

פקודות אלו יתקינו את פינטו ב 
<hl>~/opt/local/pinto</hl> ויוסיפו את התיקיות הדרושות למסלולים
ב- <hl>PATH</hl> וב- <hl>MANPATH</hl>.
ההתקנה כוללת את כל מה שפינטו צריך, כך שהתקנת פינטו לא משנה את 
שאר סביבת הפיתוח שלך, וכמו כן שינויים בסביבת הפיתוח אינם משפיעים על פינטו.


<h2>ללמוד להשתמש בפינטו</h2>

כמו כל כלי חדש, הדבר הראשון שצריך לדעת הוא איך לקבל עזרה:


<code>
pinto commands            # Show a list of available commands
pinto help <COMMAND>      # Show a summary of options and arguments for <COMMAND>
pinto manual <COMMAND>    # Show the complete manual for <COMMAND>
</code>

פינטו מגיע גם עם תיעוד נוסף, כולל מדריך שימוש ומדריך לעיון מהיר.
ניתן לגשת אל מסמכים אלו באמצעות הפקודות:

<code>
man Pinto::Manual::Introduction  # Explains basic Pinto concepts
man Pinto::Manual::Installing    # Suggestions for installing Pinto
man Pinto::Manual::Tutorial      # A narrative guide to Pinto
man Pinto::Manual::QuickStart    # A summary of common commands
</code>

<h2>יצירת מאגר</h2>

השלב הראשון בשימוש בפינטו הוא יצירת מאגר באמצעות הפקודה <hl>init</hl>:

<code>
pinto -r ~/repo init
</code>

פקודוה זו תיצור מאגר חדש בתיקייה <hl>~/repo</hl>. אם התיקייה אינה קיימת, היא תיווצר עבורך.
אם היא כבר קיימת אז היא חייבת להיות ריקה.

האופציה -r  (או -root) מציינת את מיקום המאגר. יש לציין זאת בכל פקודת פינטו.
אבל אם נמאס לך לחזור ולהקליד זאת שוב ושוב, אז תוכל להגדיר את מיקום המאגר במשתנה הסביבה
 <hl>PINTO_REPOSITORY_ROOT</hl> ואז אין צורך להשתמש עוד ב -r .


<h2>בדיקת המאגר</h2>

עכשיו שיש לנו מאגר,נבדוק ומראה מה יש בו.
כדי לראות את תוכן המאגר, השתמש בפקודה "list":

<code>
pinto -r ~/repo list
</code>

בשלב זה הרשימה תהיה ריקה כיוון שאין עוד כלום במאגר. אך הפקודה "list" תופיע די הרבה בהמשך 
ההדרכה.


<h2>הוספת מודולים מ-CPAN </h2>

נניח שאתה עובד כעת על יישום שנקרא My-App המכיל מודל בדם My::App, והוא מסתמך על 
המודול URI.  אתה יכול להכניס את המודול URI אל המאגר שלך באמצעות הפקודה <hl>pull</hl>:

<code>
pinto -r ~/repo pull URI
</code>

תתבקש להקליד הודעה עבור הלוג שתתאר את הסיבה לשינוי. 
בראש תבנית ההודעה יש הודעה פשוטה, , שיוצרה אוטומטית, ואתה יכול לערוך אותה.
תחתית תבנית ההודעה מראה את רשימת המודולים המדוייקת שנוספו.
שמור את הקובץ וסגור את עורך הטקסט לאחר שסיימת.

כעת מודול ה-URI אמור להיות במאגר הפינטו שלך. חזור שוב על הפקודה <hl>list</hl>
כדי לראות את תוכן המאגר:

<code>
pinto -r ~/repo list
</code>

הפעם הרשימה תיראה דומה לרשימה זו:

<code>
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
rf  URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.60.tar.gz
...
</code>

ניתן לראות שהמודול URI נוסף למאגר, וכמו כן גם כל המודולים הדרושים כדרישות קדם למודול URI
וכל דרישות הקדם שלהם, וכו'.

<h2>הוספת מודולים פרטיים</h2>

כעת נניח שסיימת את העבודה של My-App ואתה מוכן להפיץ את הגירסה הראשונה.
ארוז את המודול כמודול להפצה My-App-1.0.tar.gz 
 באמצעות הכלי המועדף עליך (למשל: ExtUtils::MakםeMaker, Module::Build, Module::Install וכו').
הוסף את קובץ ההפצה שלך למאגר הפינטו שלך באמצעות הפקודה <hl>add</hl>:

<code>
$> pinto -r ~/repo add path/to/My-App-1.0.tar.gz
</code>


גם במקרה זה תתבקש להכניס הודעה שמתארת את השינוי. כשתציג את תוכן המאגר כעת, הוא יכלול גם
את המודול My::App ויציג אותך כיוצר ההפצה:

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
rf  URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.60.tar.gz
...
</code>


<h2>התקנת המודולים</h2>

לאחר שכל המודולים שלך נמצאים במאגר הפינטו שלך, השלב הוא בא הוא להתקין אותם איפשהו.
בתוך הקופסה, מאגר פינטו מנוהל בדיוק כמו מאגר CPAN,
לכן הוא תואם לגמרי ל-cpanm ולכל כלי אחר להתקנת מודולי פרל.
כל מה שנדרש הוא להפנות את כלי ההתקנה למאגר הפינטו שלך:

<code>
cpanm --mirror file://$HOME/repo --mirror-only My::App
</code>

פקודה זו תבנה ותתקין את My::App *אך ורק* בשימוש במודולים שנמצאים 
במאגר הפינטו שלך. כך תקבל בדיוק את אותן גרסאות של המודולים עם כל התקנה,
אפילו אם המודול שודרג במאגר CPAN הפומבי או הוסר ממנו.

עם cpanm האופציה --mirror-only היא אופציה חשובה, כיוון שהיא מונעת
מ-cpanm לפנות אל מאגר ה-CPAN הפומבי אם המודול אינו נמצא במאגר שלך. 
אם זה קורה, אז כנראה יש שגיאה בהגדרת דרישות הקדם בקובץ ה-META
של אחד המודולים במאגר שלך. ניתן לפתור את הבעיה על ידי שימוש בפקודה 
<hl>pull</hl> כדי להוסיף את המודולים החסרים.


<h2>שידרוג מודולים</h2>

נניח שעברו מספר שבועות מאז שהפצת לראשונה את My-App ומודול URI עודכן על CPAN 
1.62. בגירסה החדשה יש מספר תיקוני באגים חיוניים שאתה רוצה לקבל.
שוב, נוכל להכניס את המודול אל המאגר באמצעות הפקודה  <hl>pull</hl>.
אך כיוון שבמאגר שלך כבר יש גירסה של מודול URI, עליך לציין שברצונך להכניס גירסה 
 <b>חדשה יותר</b> על ידי מספר הגירסה המינימלי שרצוי לך:


<code>
pinto -r ~/repo pull URI~1.62
</code>

אם תסתכל שוב על רשימת תוכן המאגר תראה הפעם את הגרסה החדשה יותר של המודול URI (וייתכן שגם תראה מודולים נוספים):

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.62  GAAS/URI-1.62.tar.gz
rf  URI::Escape                    3.38  GAAS/URI-1.62.tar.gz
rf  URI::Heuristic                 4.20  GAAS/URI-1.62.tar.gz
...
</code>

אם הגירסה החדשה מסתמכת על  מודולים נוספים או על מודולים אחרים ששודרגו,
גם הם יהיו במאגר שלך. כשתתקין את My::App, תקבל גם את גירסה 1.62 של URI.


<h2>שימוש במחסניות (Stacks)</h2>


בינתיים התייחסנו אל המאגר כאל משאב יחיד. כך כששידרגנו את URI בחלק הקודם, 
הפעולה השפיעה על כל משתמש ועל כל יישום שהשתמשו במאגר. 
השפעה כל כך גורפת אינה רצויה. עדיף לעשות את שינויים בסביבה מבודדת ולבדוק אותם 
לפני שמחייבים את כולם לשדרג. בשביל זה נועדו המחסניות (Stacks).

לכל מאגר דמוי CPAN יש אינדקס שמקשר את הגירסה העדכנית ביותר של כל מודול לארכיון שמכיל אותה.
לרוב יש אינדקס אחד לכל מאגר. במאגר פינטו יכול להיות יותר מאינדקס אחד.
כל אינדקס נקרה <b>"stack"</b>. זה מאפשר יצירת מחסניות שונות עם תלויות בדרישות קדם שונות בתוך מאגר.
ניתן לנהל מחסנית "development" לפיתוח ובנוסף מחסנית "production" לגרסאות להפצה, 
או מחסנית "perl-5.8" ומחסנית "perl-5.16". כל הוספת מודול או עידכונו משפיעים רק על מחסנית אחת.

לפני שתמשיך צריך להכיר את מחסנית ברירת המחדל (default stack).
ברוב הפעולות אין צורך לציין את שם המחסנית. אם לא מציינים במפורש שם מחסנית
אז הפקודה מופעלת על המחסנית שמסומנת כמחסנית ברירת המחדל.


בכל מאגר, בכל רגע נתון, יש תמיד לכל היותר מחסנית ברירת מחדל אחת. 
כשיצרנו את המאגר נוצרה גם מחסנית בשם "master" והיא סומנה כמחסנית ברירת המחדל.
ניתן לשנות את מחסנית ברירת המחדל, או את שם המחסנית, אבל לא ניכנס לזה כאן.
פשוט יש לזכור ש-"master" הוא שמה של המחסנית שנוצרה כשיצרנו את המאגר.

<h3>יצירת מחסנית (Stack)</h3>


נניח שהמאגר שלך מכיל את גירסה 1.60 של URI אבל ב-CPAN הגירסה המעודכנית היא גירסה 1.62, כמו בדוגמה הקודמת.
אתה רוצה לנסות את שדרוג, אבל הפעם אתה הולך לנסות אותו במחסנית נפרדת.

עד כה, כל מה שהוספת או הכנסת למאגר נכנס למחסנית "master". אז קודם כל ניצור העתק של המחסנית
בעזרת הפקודה  <hl>copy</hl>:

<code>
pinto -r ~/repo copy master uri_upgrade
</code>

פקודה זו יוצרת מחסנית חדשה בשם "uri_upgrade". אם תרצה לראות את תוכן המחסנית החדשה, השתמש בפקודה
<hl>list</hl> עם האופציה "--stack":


<code>
pinto -r ~/repo list --stack uri_upgrade
</code>

הרשימה צריכה להיות זהה לרשימה במחסנית "master":

<code>
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf  URI                            1.60  GAAS/URI-1.60.tar.gz
...
</code>

<h3>שידרוג מחסנית (Stack)</h3>

עכשיו כשיש לך מחסנית נפרדת, אתה יכול לנסות לשדרג את URI. כמו קודם, תשתמש בפקודה
<hl>pull</hl> . רק הפעם תאמר לפינטו להכניס את המודולים אל המחסנית "uri_upgrade" :

<code>
pinto -r ~/repo pull --stack uri_upgrade URI~1.62
</code>

עכשיו ניתן להשוות את המחסניות "master" ו- "uri_upgrade" באמצעות הפקודה "diff":

<code>
pinto -r ~/repo diff master uri_upgrade

+rf URI                                              1.62 GAAS/URI-1.62.tar.gz
+rf URI::Escape                                      3.31 GAAS/URI-1.62.tar.gz
+rf URI::Heuristic                                   4.20 GAAS/URI-1.62.tar.gz
...
-rf URI                                              1.60 GAAS/URI-1.60.tar.gz
-rf URI::Escape                                      3.31 GAAS/URI-1.60.tar.gz
-rf URI::Heuristic                                   4.20 GAAS/URI-1.60.tar.gz
</code>

הקלט דומה לקלט של הפקודה diff(1).
רשומות שמתחילות ב "+" הן רשומות שנוספו ורשומות שמתחילות ב "-" הן רשומות שהוסרו. 
ניתן לראות שמודולים מההפצה של URI-1.60 הוחלפו במודולים מההפצה URI-1.62.


<h3>התקנה ממחסנית (Stack)</h3>

לאחר שהמודולים החדשים הותקנו במחסנית "uri_upgrade" תוכל לנסות לבנות ולהתקין את היישום שלך
על ידי כך שתפנה את cpanm אל המחסנית.
מחסנית היא בסך הכל תת-תיקייה בתוך המאגר, כך שכל מה שיש לעשות הוא להוסיף אותה אל ה-URL:

<code>
cpanm --mirror file://$HOME/repo/stacks/uri_upgrade --mirror-only My::App
</code>

אם כל הבדיקות עברו בהצלחה, תוכל לשדרג בביטחה את מודול URI
לגירסה 1.62 גם במחסנית "master" בעזרת הפקודה <hl>pull</hl>.
כיוון שמחסנית "master" היא מחסנית ברירת המחדל, אין צורך לציין את שם המחסנית:

<code>
pinto -r ~/repo pull URI~1.62
</code>

<h2>שימוש בהצמדות (Pins)</h2>

מחסניות (Stacks) הן כלי מצוין לבדיקת ההשפעות של החלפת מודולים שהיישום שלך מסתמך עליהם.
אבל מה עושים אם המודולים לא עוברים את הבדיקות?
אם הבעיה היא ב- My-App ואתה יכול לתקן אותה במהירות, אז אתה יכול לתקן את הקוד שלך,
להפיץ את גירסה 2.0 של My-App ואז להמשיך ולהעדכן את המודול URI על המחסנית "master".

אבל אם הבעיה היא באג במודול URI או שייקח הרבה זמן לתקן את My-App, אז יש לך בעיה.
אתה לא רוצה שמישהו אחר ישדרג את URI, ואתה גם לא רוצה שהמודול ישודרג במקרה כדי לקיים 
דרישת קדם אחרת שאולי יש ל- My-App. עד שתדע שהבעיה תוקנה, תצטרך למנוע את השידרוג של 
המודול URI. בשביל זה נועדו הצמדות (Pins).

<h3>הצמדת מודול</h3>

כשאתה מצמיד מודול, אתה מאלץ את המודול להשאר בגירסה המותקנת. כל נסיון לשדרג את המודול
(בין אם ישירות ובין אם דרך דרישות קדם של מודול אחר) ייכשלו.
להצמדת מודול יש להשתמש בפקודה  <hl>pin</hl>:

<code>
pinto -r ~/repo pin URI
</code>

אם תסתכל שוב בתוכן המחסנית "master" תראה משהו כזה:

<code>
...
rl  My::App                         1.0  JEFF/My-App-1.0.tar.gz
rf! URI                            1.60  GAAS/URI-1.60.tar.gz
rf! URI::Escape                    3.31  GAAS/URI-1.60.tar.gz
...
</code>

הסימן "!" בתחילת הרשומה מציין שהמודול המסומן הוצמד. אם מישהו
ינסה לעדכן את מודול URI או להוסיף הפצה שדורשת גירסה חדשה יותר של URI
פינטו יציג אזהרה ויסרב לקבל את ההפצות החדשות. 
שים לב שכל המודולים בהפצה URI-1.60 סומנו, כך שאי אפשר לשדרג מודול שידרוג חלקי 
(מצב כזה יכול לקרות כשמודול מועבר אל תוך הפצה אחרת).

<h3>ביטול הצמדה מודול</h3>

נניח שלאחר זמן מה תיקנת את הבעיה ב- My-App או שהופצה גירסה חדשה של מודול URI עם תיקון של הבאג.
ניתן לבטל את ההצמדה של מודול URI מהמחסנית בעזרת הפקודה <hl>unpin</hl>:

<code>
pinto -r ~/repo unpin URI
</code>

בשלב זה אתה חופשי לשדרג את המודול URI לגירסה העדכנית ביותר מתי שתרצה.
כמו שקורה בהצמדה, שמבטלים הצמדה, היא מבוטלת לכל המודולים שכלולים בהפצה.

<h2>שימוש משולב בהצמדות (Pins) ובמחסניות (Stacks)</h2>

במקרים רבים משתמשים בהצמדות ובמחסניות כדי לסייע לניהול שינויים בחלק מתהליך הפיתוח.
למשל ניתן ליצור מחסנית בשם "prod" שכוללת את המודולים הנסמכים(מודולים הדרושים כדרישות קדם) שידוע שהם טובים.
בו בזמן ניתן ליצור גם מחסנית בשם "dev" שמכילה מודולים נסמכים נוספים להפצה הבאה שלך.
בהתחלה המחסנית "dev" היא פשוט העתק של המחסנית "prod".

עם התקדמות תהליך הפיתוח ניתן לשדרג או להוסיף מודולים במחסנית "dev".
אם מודול משודרג מקלקל את היישום שלך, אז תצמיד את  אותו מודל במחסנית "prod" כדי לסמן שאין לשדרג אותו.

<h3>הצמדות (Pins) וטלאים (Patches)</h3>

לפעמים מגלים שבגירסה חדשה של הפצה ב-CPAN יש באג אבל המתכנת של ההפצה אינו זמין
או אינו מוכן לתקן את הבאג (לפחות לא לפני שמגיע הזמן להפיץ את הגירסה הבאה שלך).
במקרה כזה ייתכן שתחליט לעשות טלאי מקומי של הפצת ה-CPAN.

נניח שיצרת פיצול (fork) של הקוד למודול URI ויצרת גרסה מקומית של ההפצה שנקראת URI-1.60_PATCHED.tar.gz.
ניחן להוסיף אותה למאגר עם הפקודה <hl>add</hl>:

<code>
pinto -r ~/repo add path/to/URI-1.60_PATCHED.tar.gz
</code>

במקרה זה רצוי גם להצמיד את המודול כיוון שאינך רוצה שהוא יעודכן עד שאתה בטוח 
שהגרסה החדשה מ-CPAN  כוללת את כל הטלאי שלך או שהמתכנת של המודול תיקן את הבאג הדרך אחרת.


<code>
pinto -r ~/repo pin URI
</code>

כשהמתכנת של המודול URI מפיץ את גירסה 1.62 וודאי תרצה לבדוק אותה לפני 
שתבטל את הצמדתה של הגירסה המוטלאת המקומית שלך.
בדיוק כמו קודם, ניתן לבצע זאת על ידי יצירת עותק של המחסנית עם הפקודה <hl>copy</hl>.
בוא נקרה הפעם למחסנית החדשה "trial":

<code>
pinto -r ~/repo copy master trial
</code>

לפני שתוכל לשדרג את URI על המחסנית "trial", תצטרך לבטל שם את ההצמדה:

<code>
pinto -r ~/repo unpin --stack trial URI
</code>

עכשיו אפשר לשדרג את URI במחסנית ולנסות לבנות את My::App כך:

<code>
pinto -r ~/repo pull --stack trial URI~1.62
cpanm --mirror file://$HOME/repo/stacks/trial --mirror-only My::App
</code>

אם הכל עובד כשורה, בטל את ההצמדה במחסנית "master" ומשוך אליה את הגירסה החדשה של המודול URI.

<code>
pinto -r ~/repo unpin URI
pinto -r ~/repo pull URI~1.62
</code>

<h2>סקירת שינויים קודמים</h2>

כפי שראית עד כה, כל פקודה שמשנה את מצב המחסנית דורשת הכנסת הודעה ללוג שמתארת את השינוי.
ניתן לסקור את ההודעות באמצעות הפקודה <hl>log</hl> :

<code>
pinto -r ~/repo log
</code>

התצוגה אמורה להראות בערך כך:

<code>
revision 4a62d7ce-245c-45d4-89f8-987080a90112
Date: Mar 15, 2013 1:58:05 PM
User: jeff

     Pin GAAS/URI-1.59.tar.gz

     Pinning URI because it is not causes our foo.t script to fail

revision 4a62d7ce-245c-45d4-89f8-987080a90112
Date: Mar 15, 2013 1:58:05 PM
User: jeff

     Pull GAAS/URI-1.59.tar.gz

     URI is required for HTTP support in our application

...
</code>

הכותרת של כל הודעה מראה מי ביצע את השינוי ומתי זה קרה.
כמו כן יש לה מזהה ייחודי בדומה לתמצית (digest) SHA-1 של Git. ניתן להשתמש במזהים
כדי לראות את ההבדלים בין גרסאות שונות או כדי להחזיר את המחסנית למצב קודם 
[הערה: אפשרות זועדיין אינה מיושמת]


<h2>סיכום</h2>

מדריך זה הסביר את הפקודות הבסיסיות ליצירת מאגר פינטו ואיכלוס המאגר במודולים.
כמו כן ראינו איך להשתמש במחסניות (Stacks) ובהצמדות (Pins) כדי לאפשר ניהול תלויות ונסמכים 
ועל ידי כך להתמודד עם מכשולים שכיחים בתהליכי פיתוח.

לכל פקודה יש מספר אופציות שלא נדונו במדריך זה, 
וכמו כן קיימות פקודות נוספות שכלל לא הוזכרו כאן.
אני מציע לכם לקרוא את התיעוד במדריך למשתמש כדי ללמוד עוד על כל הפקודות.



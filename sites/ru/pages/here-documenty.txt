=title Here-документы, или как создать многостроковую переменную в Perl
=timestamp 2013-09-09T19:01:01
=indexes <<, /m, /g, q, qq
=status show
=original here-documents
=books beginner
=author szabgab
=translator spidamoo
=comments_disqus_enable 0

=abstract start

Время от времени нам нужно создать строковую переменную, которая занимает несколько строк. Как и 
всегда в Perl, для этого есть несколько способов. Одно из типичных решений - использование 
here-документов.

=abstract end

<b>Here-document</b> позволяет создать строковую переменную, занимающую <b>несколько строк</b> и
сохранить пробелы и переводы строк. Если запустить следующий код, он выведет в точности то, что мы
видим от слова "Дорогой" и до строки перед вторым END_MESSAGE.

<h2>Неинетрполируемый here-документ</h2>

<code lang="perl">
#!/usr/bin/perl
use strict;
use warnings;

my $name = 'Foo';

my $message = <<'END_MESSAGE';
Дорогой $name,

я собираюсь отправить тебе это сообщение.

с наилучшими пожеланиями
  Perl Maven
END_MESSAGE

print $message;
</code>

Вывод:

<code>
Дорогой $name,

я собираюсь отправить тебе это сообщение.

с наилучшими пожеланиями
  Perl Maven
</code>

Here-документ начинается с двух знаков "меньше" <hl>&lt;&lt;</hl> и произвольной строки, которая 
будет указателем окончания here-документа, и точки с запятой <hl>;</hl>, указывающей конец выражения.
Что довольно странно, ведь выражение на этом не заканчивается. Содержание here-документа только
как раз только начинается со следующей строки (в нашем случае со слова "Дорогой") и продолжается до
того места, где perl найдет наш произвольный указатель окончания. В данном случае строку 
<b>END_MESSAGE</b>.

Если вы уже видели here-документы в коде, возможно, вас удивили одиночные кавычки вокруг первого
<b>END_MESSAGE</b>. Скорее всего, если вы встречали примеры here-документов в интернете или в 
корпоративных сетях, там открывающая часть была без кавычек, вроде этого:

<code lang="perl">
my $message = <<END_MESSAGE;
...
END_MESSAGE
</code>

Это сработает так же, как если бы вы поместили END_MESSAGE в двойные кавычки, как в следующем 
примере, но это <b>устаревший</b> синтаксис и он перестанет работать начиная с версии 5.20. 
<b>Не</b> делайте так! Не используйте here-документы без кавычек вокруг определения указателя 
окончания.

<code lang="perl">
my $message = <<"END_MESSAGE";
...
END_MESSAGE
</code>

Если вам уже знакома <a href="/kavychki-interpolyaciya-i-ekranirovanie-strok-v-perl">разница между 
строками в одиночных и двойных кавычках</a> в Perl, то, наверное, вы не удивитесь тому, что 
here-документы работают точно так же. Единственная разница в том, что кавычки ставятся вокрг 
указателя окончания, а не вокруг самой строки. Если кавычек нет, Perl по умолчанию понимает такую 
строку так, как если бы она была в двойных кавычках.
If you already know the

Если вы вернетесь к первому примеру, вы заметите в нашем here-документе переменную <hl>$name</hl>, 
которая осталась в таком же виде в выводе. Это потому, что Perl не пытался заменить $name содержимым
этой переменной. (Мы могли бы и не объявлять эту переменную в коде. Вы можете попробовать запустить
этот скрипт, убрав строку с <hl>my $name = 'Foo';</hl>.)

<h2>Интерполяция в here-документе</h2>

В следующем примере мы используем двойные кавычки вокруг указателя окончания, и таким образом 
переменная <hl>$name</hl> будет интерполирована:

<code lang="perl">
use strict;
use warnings;

my $name = 'Foo';
my $message = <<"END_MSG";
Привет $name,

Как дела?
END_MSG

print $message;
</code>

Результат выполнения этого скрипта:

<code>
Привет Foo,

как дела?
</code>

<h2>Внимание: точное повторение указателя окончания в конце</h2>

Обратите внимание. Необходимо убедиться, что указатель окончания должен быть скопирован в конце 
текста <b>в точности</b> как в начале. Никаких пробелов в начале или в конце. Иначе Perl не 
распознает его и будет думать, что это продолжение here-документа. Это в том числе значит, что 
нельзя ставить отступы перед указателем окончания, чтобы они соответствовали отступам в остальном 
коде. Или можно?

<h2>Here-документы и отступы</h2>

Если нам нужен here-документ в месте, где должны быть отступы перед кодом, это порождает две 
проблемы:

<code lang="perl">
#!/usr/bin/perl
use strict;
use warnings;

my $name = 'Foo';
my $send = 1;

if ($send) {
    my $message = <<"END_MESSAGE";
        Дорогой $name,
    
        я собираюсь отправить тебе это сообщение.
    
        с наилучшими пожеланиями
          Perl Maven
END_MESSAGE
    print $message;
}
</code>

Первая состоит в том, что, как уже упоминалось, указатель окончания строки должен быть в точности
одинаковым в начале и в конце документа, так что в конце перед ним не может быть отступов.

Вторая проблема в том, что в выводе мы увидим все эти пробелы перед каждой строкой:

<code>
        Дорогой Foo,
    
        я собираюсь отправить тебе это сообщение.
    
        с наилучшими пожеланиями
          Perl Maven
</code>

Недостаток отступов перед указателем окончания может быть решен, если мы сразу включим их при его 
объявлении в начале документа: (здесь я использую 4 пробела, так как табы плохо смотрятся в статье,
но в коде их можно использовать, если вы принадлежите к лагерю сторонников отступов-с-помощью-табов)

<code lang="perl">
    my $message = <<"    END_MESSAGE";
       ...
    END_MESSAGE
</code>

Лишние отступы в самом тексте можно убрать с помощью подстановки при присваивании.

<code lang="perl">
    (my $message = <<"    END_MESSAGE") =~ s/^ {8}//gm; 
        ...
    END_MESSAGE
</code>

В подстановке мы заменяем 8 предстоящих пробелов на пустую строку. Мы ипользуем два модификатора:
<hl>/m</hl> меняет поведение <hl>^</hl> таким образом, чтобы он соответствовал не <b>началу 
строковой переменной</b>, а <b>началу каждой строки</b>. <hl>/g</hl> указывает, что подстановка 
должна работать <b>глобально</b>, то есть повторяться до тех пор, пока возможно.

С этими двумя флагами подстановка уберем 8 предстоящих пробелов из каждой строки в переменной слева 
от <hl>=~</hl>. Необходимо заключить в скобки выражение слева от оператора, так как приоритет 
оператора присваивания (<hl>=</hl>) ниже, чем у оператора регулярного выражения <hl>=~</hl>. Без
скобок perl бы сначала попытался применить регуляроне выражение к here-документу, что закончилось бы
ошибкой на этапе компиляции:

Can't modify scalar in substitution (s///) at programming.pl line 9, near "s/^ {8}//gm;"

<h2>Использование q или qq вместо here-документов</h2>

После всех этих объяснений я уже не уверен, что мне стоит советовать вам использовать here-документы.
Во многих случаях вместо них я использую оператор <hl>qq</hl> или <hl>q</hl>, в зависимости от того,
нужно ли интерполировать переменные:
<code lang="perl">
#!/usr/bin/perl
use strict;
use warnings;

my $name = 'Foo';
my $send = 1;

if ($send) {
    (my $message = qq{
        Дорогой $name,
    
        я хочу отправить тебе это сообщение.
    
        с наилучшими пожеланиями
          Perl Maven
        }) =~ s/^ {8}//mg;
    print $message;
}
</code>


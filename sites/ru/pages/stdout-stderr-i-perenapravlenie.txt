=title Стандартный канал вывода, стандартный канал ошибок и перенаправление в командной строке
=timestamp 2013-10-22T14:00:03
=indexes STDOUT, STDERR, /dev/null, $|, buffering
=status show
=original stdout-stderr-and-redirection
=books beginner
=author szabgab
=translator spidamoo
=comments_disqus_enable 0

=abstract start
Когда вы запускаете программу в командной строке, она автоматически получает два отдельных канала 
для вывода. Один из них - <b>Стандартный канал вывода, Standard Output</b>, а второй - 
<b>Сдандартный канал ошибок, Standard Error</b>.

По умолчанию они оба выводятся на экран (в оболочке, терминале или окне командной строки) и, таким
образом, они смешиваются, но пользователь программы может разделить их, и <b>перенаправить</b> один
из них или оба в файл.

=abstract end

Идея в том, что обычный вывод приложения идет в канал вывода, а все предупреждения и сообщения об
ошибках идут в канал ошибок.

Как программист, вы решаете, какой вывод считается частью нормального хода выполнения вашей 
программы, и отправляете его в стандартный канал вывода. Остальное, то, что является ненормальным,
попадет в стандартный канал ошибок.

Если пользователь хочет видеть только нормальный вывод, он может перенаправить канал ошибок в файл,
чтобы просмотреть его позже, отдельно.

<h2>Как выводить сообщения об ошибках?</h2>

В Perl, когда программа запускается, эти два канала вывода представляются двумя символами: 
<hl>STDOUT</hl> для стандартного канала вывода, и <hl>STDERR</hl> для стандартного канала ошибок.

Изнутри программы Perl вы можете выводить сообщение в любой из этих каналов, поместив
соответствующий символ сразу после ключевого слова <hl>print</hl>:

<code lang="perl">
print STDOUT "Welcome to our little program\n";
print STDERR "Could not open file\n";
</code>

(Обратите внимание, после слов STDOUT и STDERR в этих выражениях нет запятой <hl>,</hl>!)

Если запустить этот скрипт (<hl>perl program.pl</hl>), на экране мы увидим следующее:

<code>
Welcome to our little program
Could not open file
</code>

То есть мы не увидим, что эти сообщения пришли из разных каналов вывода.

<h2>Канал вывода по умолчанию</h2>

По сути, слово <hl>STDOUT</hl> можно опустить, и написать просто:

<code lang="perl">
print "Welcome to our little program\n";
print STDERR "Could not open file\n";
</code>

Когда скрипт perl запускается, STDOUT назначается <b>каналом вывода по умолчанию</b>. Это значит, 
что любая операция вывода, для которой явно не указан канал, выведет данные в STDOUT.

<h2>Перенаправление стандартного канала вывода</h2>

(В дальнейших примерах предполагается, что вы используете bash-совместимую оболочку. Другие оболочки
могут работать по-другому.)

Как пользователь, не глядя в код, мы можем разделить два канала: если выполнить команду 
<hl>perl program.pl > out.txt</hl>, символ <hl>></hl> <b>перенаправит</b> канал вывода в файл 
out.txt. Так что на экране мы увидим только содержимое стандартного канала ошибок.

<code>
Could not open file
</code>

Если открыть файл out.txt (с помощью Блокнота, vim или любого другого текстового редактора), мы 
увидим в нем текст <hl>Welcome to our little program</hl>.

<h2>Перенаправление стандартного канала ошибок</h2>

С другой стороны, если запустить скрипт командой <hl>perl program.pl 2> err.txt</hl>, то символ 
<hl>2></hl> <b>перенаправит</b> канал ошибок в файл err.txt.

На экране мы увидим:

<code>
Welcome to our little program
</code>

А если откроем файл err.txt, то в нем обнаружим: <hl>Could not open file</hl>.

<h2>Перенаправление обоих каналов</h2>

Мы можем перенаправить и оба канала одновременно с помощью обоих символов командной строки.

Запустив скрипт командой <hl>perl program.pl > out.txt 2> err.txt</hl>, на экране мы ничего не 
увидим. Все, что выводилось в стандартный канал вывода, окажется в файле out.txt, а все, что было
в канале ошибок - в err.txt.

В этих примерах названия файлов out.txt и err.txt совершенно произвольны. Вы можете использовать
любые пути по своему усмотрению.

<h2>/dev/null</h2>

В системах Unix/Linux существует специальный файл под названием <hl>/dev/null</hl>. Он работает как
черная дыра. Все, что записывается в этот файл, исчезает без следа. В основном это используется, 
когда пользователь хочет выкинуть либо стандартный вывод, либо ошибки запускаемого приложения.

Например, у нас есть приложение, которое мы не можем изменить, и оно вываливает кучу сообщений в
стандартный канал ошибок. Если мы не хотим видеть это на экране, можем перенаправить их в файл. Но
если так сделать, диск может быстро переполниться. Так что мы перенаправляем канал ошибок в 
/dev/null, и операционная система помогает нам избавиться от &laquo;мусора&raquo;.

<hl>perl program.pl 2> /dev/null</hl>

<h2>nul в MS Windows</h2>

В MS Windows <hl>/dev/null</hl> соответствует просто <hl>nul</hl>

<hl>perl program.pl > nul</hl> перенаправит стандартный вывод в никуда, а 
<hl>perl program.pl 2> nul</hl> сделает то же со стандартным каналом ошибок.

<h2>Поддержка Unix/Linux/Windows?</h2>

Раздельный вывод в STDOUT и STDERR внутри Perl'а работает на любой операционной системе, но 
перенаправление может не сработать. Это зависит от того, как работает операционная система, или,
точнее, оболочка (командная строка).

Большая часть примеров выше должна работать на Unix/Linux, как и на MS Windows. Конкретно 
<hl>/dev/null</hl> работает только на системах Unix/Linux.

<h2 id="buffering">Порядок вывода (буферизация)</h2>

Небольшое предупреждение:

Этот код:

<code lang="perl">
print "до";
print STDERR "Небольшая проблема.\n";
print "после";
</code>

Может вывести что-нибудь вроде:

<code>
Небольшая проблема.
допосле
</code>

Обратите внимание, что &laquo;до&raquo; и &laquo;после&raquo; попали на экран <b>после</b> сообщения об ошибке. Несмотря
на то, что мы ожидали увидеть &laquo;до&raquo;, собственно, до сообщения об ошибке.

Причина этого в том, что по умолчанию Perl буферизирует вывод в STDOUT, но не буферизирует STDERR.
Чтобы выключить буферизацию, можно использовать волшебную палочку <hl>$|</hl>:

<code lang="perl">
$| = 1;

print "до";
print STDERR "Небольшая проблема.\n";
print "после";
</code>

<code>
доНебольшая проблема.
после
</code>

Также обычно можно решить эту проблему, добавив перевод строки в STDOUT:

<code lang="perl">
print "до\n";
print STDERR "Небольшая проблема.\n";
print "после";
</code>

И вывод выглядит даже лучше:

<code>
до
Небольшая проблема.
после
</code>





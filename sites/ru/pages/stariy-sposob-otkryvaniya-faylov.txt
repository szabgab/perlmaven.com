=title Не открывайте файлы по-старому
=timestamp 2013-10-25T12:00:01
=indexes open
=status show
=original open-files-in-the-old-way
=books beginner
=author szabgab
=translator spidamoo
=comments_disqus_enable 0

=abstract start

Ранее в <a href="/perl-tutorial">Учебнике Perl</a> мы узнали, как открывать файлы для чтения или 
записи. К несчастью, поискав в интернете или в корпоративных проектах, зачастую можно увидеть 
использование немного другого синтаксиса.

Давайте узнаем, почему так делают, в чем там проблема и почему следует этого избегать.

=abstract end

<h2>Так что же делать?</h2>

Прежде чем рассказывать, как делать не надо, позвольте дать ссылки на статьи, в которых объясняется,
как делать надо:

Прочитайте, <a href="/otkrytie-i-chtenie-faylov">как открывать файлы современным способом</a> и как
<a href="/zapis-v-fayl-na-perl">в Perl открывать файлы для записи</a>.

Теперь давайте вернемся к старым, и уже-не-таким-хорошим практикам.

<h2>Старый, не рекомендуемый к использованию способ</h2>

До выхода perl 5.6 - то есть до 2000 года - чтобы открыть файл для записи, мы писали такой код:

<code lang="perl">
open OUT, ">$filename" or die ...;
</code>

и так для чтения:

<code lang="perl">
open IN, $filename or die ...;
</code>

Часть &laquo;or die&raquo; с тех пор не изменилась, здесь мы ее целиком не пишем.

Как вы видите, <hl>open</hl> принимает два параметра. Первый - это последовательность букв (обычно в
верхнем регистре). Сюда попадет файловая ссылка. Второй - комбинация режима открытия и пути к 
открываемому файлу.

На деле, в первом случае мы видим знак &laquo;больше&raquo;, означающий, что мы открываем файл для
записи, но во втором примере мы пропустили режим открытия. Это из-за того, что <hl>open()</hl> по
умолчанию использует режим чтения.

Здесь два больших отличия от изученной нами практики:

<h2>Глобальная файловая ссылка</h2>

Первое состоит в использовании для файловой ссылки странной переменной без <hl>$</hl> в начале. (По
сути, это <b>bareword</b>, но он не вызывает ошибки <a href="/bareword-v-perl">Bareword not 
allowed while "strict subs" in use</a>.)

Это по-прежнему работает, как и в прежние времена, но есть некоторые связанные с этим проблемы:

Использованная переменная становится глобальной для всего скрипта, так что если кто-то использует 
для своей переменной то же имя (в нашем примере это IN или OUT), то она перекроется с вашей.

Кроме того, такие переменные сложнее, чем обычные скаляры, передавать функциям.

<h2>open с двумя параметрами</h2>

Второе отличие это то, что в этих примерах в <hl>open</hl> передается только два параметра.

Что если переменная <hl>$filename</hl>, которую мы использовали в открытии файла для чтения, 
содержит >/etc/passwd ?

Ой.

Строка <hl>open IN, $filename</hl> откроет этот файл для записи.

Мы только что удалили файл с паролями на нашем Linux'е.

Это нехорошо.

<h2>Нужно закрывать файловую ссылку</h2>

Еще одно преимущество <b>скалярных переменных с ограниченной областью видимости</b>, применяемых для
хранения файловых ссылок, состоит в том, что файлы автоматически закрываются, когда переменная 
покидает область видимости.

<h2>Как избегать этих проблем?</h2>

Лучше всего избегать использования обеих этих праткик, и использовать &laquo;новый&raquo; 
(появившийся в 2000 году!) <a href="/otkrytie-i-chtenie-faylov">open с тремя параметрами и скалярную
лексическую переменную</a> для открытия файлов и хранения файловой ссылки.

В <a href="http://www.perlcritic.com/">Perl::Critic</a> даже есть политики, которые помогут вам 
проанализировать код и найти все места, где кто-то использовал одну из форм, приведенных выше.

<h2>Хорошее и Плохое чтение</h2>

Плохое:

<code lang="perl">
open IN, $filename or die ...;
</code>

Хорошее:

<code lang="perl">
open my $in, '<', $filename or die ...;
</code>

<h2>Хорошая и Плохая запись</h2>

Плохая:

<code lang="perl">
open IN, ">$filename" or die ...;
</code>

Хорошая:

<code lang="perl">
open my $in, '>', $filename or die ...;
</code>



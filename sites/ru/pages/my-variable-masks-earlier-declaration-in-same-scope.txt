=title "my" variable masks earlier declaration in same scope
=timestamp 2013-07-25T13:00:02
=indexes my, scope
=status show
=original my-variable-masks-earlier-declaration-in-same-scope
=books beginner
=author szabgab
=translator spidamoo
=comments_disqus_enable 0

=abstract start

Это предупреждение на этапе компиляции, которое вы увидите, если по ошибке попытаетесь объявить одну
и ту же переменную дважды в одной области видимости.

<code>
"my" variable ... masks earlier declaration in same scope at ... line ...
</code>

Как это происходит, и как работает переобъявление переменной на каждой итерации цикла?

Если нельзя написать <hl>my $x</hl> два раза в одной области видимости, то как нам обнулить эту 
переменную?

=abstract end

Рассмотрим различия между этими двумя случаями:

<h2>Простой скрипт</h2>

<code lang="perl">
use strict;
use warnings;

my $x = 'this';
my $z = rand();
my $x = 'that';
print "OK\n";
</code>

В этом случае мы получим следующее предупреждение на этапе компиляции:

<code>
"my" variable $x masks earlier declaration in same scope at ... line 7. )
</code>

Понятно, что это только предупреждение, и при запуске скрипт также выведет "OK".


<h2>Блок в условном выражении</h2>

<code lang="perl">
use strict;
use warnings;

my $z = 1;
if (1) {
    my $x = 'this';
    my $z = rand();
    my $x = 'that';
}
</code>

Здесь мы получим следующее предупреждение:

<code>
"my" variable $x masks earlier declaration in same scope at ... line 7.
</code>

В обоих случаях мы объявили <hl>$x</hl> дважды в одной области видимости, и в результате будет
сгенерировано предупреждение на этапе компиляции.

Во втором примере мы также дважды объявили <hl>$z</hl>, но от этого никакого предупреждения не 
появилось. Это потому, что <hl>$z</hl> в блоке находится в другой 
<a href="/oblast-vidimosti-v-perl">области видимости</a>.

<h2>Область видимости функции</h2>

Тот же код, но в функции:

<code lang="perl">
use strict;
use warnings;

sub f {
    my $x = 'this';
    my $z = rand();
    my $x = 'that';
}
f(1);
f(2);
</code>

Здесь мы тоже получим предупреждение на этапе компиляции (один раз) для переменной <hl>$x</hl>.
Несмотря на то, что переменная <hl>$z</hl> будет "пробуждаться к жизни" несколько раз, при каждом
выхове этой функции. Это в порядке вещей. Переменная <hl>$z</hl> не вызывает предупреждения: Perl
может создавать одну переменную дважды, только нам нельзя этого делать. Во всяком случае, не в 
пределах одной области видимости.

<h2>Область видимости цикла for</h2>

Тот же код, но в цикле:

<code lang="perl">
use strict;
use warnings;

for (1 .. 10) {
    my $x = 'this';
    my $z = rand();
    my $x = 'that';
}
</code>

Здесь мы тоже получим то же предупреждение один(!) раз для <hl>$x</hl>, но не для <hl>$z</hl>.

В этом коде одно и то же происходит <b>каждую</b> итерацию: Perl выделяет память для переменной
<hl>$z</hl>.

<h2>Что же в действительности означает "my"?</h2>

Смысл <hl>my $x</hl> в том, что вы говорите perl'у, а именно <hl>strict</hl>'у, что вы хотите 
использовать private переменную <b>$x</b> в текущей <a href="/oblast-vidimosti-v-perl">области
видимости</a>. Без этого perl будет искать объявление этой переменной в областях видимости высшего
уровня и, если нигде не найдет, то выдаст ошибку этапа компиляции 
<a href="/global-symbol-requires-explicit-package-name">Global symbol requires explicit package name</a>.
Каждый блок, каждый вызов функции, каждая итерация цикла - это отдельный мир.

С другой стороны, написав <hl>my $x</hl> дважды в одной области видимости, вы по сути пытаетесь 
сказать perl'у два раза одно и то же. В этом нет необходимости, и обычно это значит, что где-то 
допущена ошибка.

Другими словами, предупреждение, которое мы получаем, относится к <b>компиляции</b> кода, а не к 
выполнению. Оно относится к объявлению переменной разработчиком, а не к выделению памяти perl'ом во
время выполнения.

<h2>Как обнулить существующую переменную?</h2>

Так если мы не можем написать <hl>my $x;</hl> дважды в одной области видимости, как нам сделать
эту переменную "пустой"?

Прежде всего, если переменная объвлена внутри области видимости, то есть между фигурными скобками,
она автоматически исчезнет, когда по ходу выполнения программа покинет эту 
<a href="/oblast-vidimosti-v-perl">область видимости</a>.

Если же вам нужно "обнулить" скалярную переменную в текущей области видимости, присвойте ей 
<hl>undef</hl>, а если это <a href="https://perlmaven.com/undef-on-perl-arrays-and-hashes">массив или
хэш</a>, чтобы опустошить их, нужно присвоить им пустой список:

<code lang="perl">
$x = undef;
@a = ();
%h = ();
</code>

Итак, внесем ясность. "my" сообщает perl'у, что мы хотим использовать переменную. Когда Perl доходит
до кода с таким объявлением переменной, он выделяет память под эту перемунную и ее содержимое. Когда
Perl дойдет до кода <hl>$x = undef;</hl>, <hl>@x = ();</hl> или <hl>undef @x;</hl>, он удалит 
содержимое существующей переменной.



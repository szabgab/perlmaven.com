---
title: "Perl Arrays"
timestamp: 2013-12-21T12:00:02
tags:
  - "@"
  - array
  - arrays
  - length
  - size
  - foreach
  - Data::Dumper
  - scalar
  - push
  - pop
  - shift
published: true
original: perl-arrays
books:
  - beginner
author: szabgab
translator: spidamoo
---


В этой части [Учебника Perl](/perl-tutorial) мы узнаем о <b>массивах в Perl</b>. Это 
обзор работы массивов в Perl. Более подробные объяснения рассмотрим позже.

Имена переменных для массивов в Perl начинаются с &laquo;собаки&raquo;: `@`.

Из-за того, что мы настаиваем на использовании режима `strict`, эти переменные перед первым
использованием также нужно объявлять с помощью ключевого слова `my`.


Не забудьте, что все приведенные ниже примеры предполагают, что в начале вашего скрипта написано

```perl
use strict;
use warnings;
use 5.010;
```

Объвляем массив:

```perl
my @names;
```

Создаем и присваиваем значения:

```perl
my @names = ("Foo", "Bar", "Baz");
```


## Дебаггинг массива

```perl
use Data::Dumper qw(Dumper);

my @names = ("Foo", "Bar", "Baz");
say Dumper \@names;
```

Выведет:

```
$VAR1 = [
        'Foo',
        'Bar',
        'Baz'
      ];
```

## Цикл foreach и массмвы perl

```perl
my @names = ("Foo", "Bar", "Baz");
foreach my $n (@names) {
  say $n;
}
```

выведет:

```
Foo
Bar
Baz
```

## Обращение к элементу массива

```perl
my @names = ("Foo", "Bar", "Baz");
say $names[0];
```

Обратите внимание, что при обращении к одному элементу массива сигил меняется с `@` на 
`$`. Это может ввести кого-то в заблуждение, но если подумать, становится довольно очевидно,
в чем тут дело.

`@` указывает на множественное, а `$` указывает на единичное. При обращении к одному
элементу массива он ведет себя так же, как и обычная скалярная переменная.

## Индексация массива

Индексы массива отсчитываются с нуля. Самый большой индекс всегда содержится в переменной 
`$#имя_массива`. Так что

```perl
my @names = ("Foo", "Bar", "Baz");
say $#names;
```

Выведет 2, так как индексам будут 0, 1 и 2.

## Длина или размер массива

В Perl нет специальной функции, чтобы получить размер массива, но есть несколько способов узнать эту
величину. Например, размер массива всегда на один больше, чем старший индекс. В приведенном примере
<b>размером</b> или <b>длиной</b> массива было бы `$#names+1`.

Кроме того, для получения размера массива можно использовать функцию `scalar`:

```perl
my @names = ("Foo", "Bar", "Baz");
say scalar @names;
```

Выведет 3.

Функция scalar это функция приведения, которая, среди прочего, превращает массив в скаляр. По
произвольному, но мудрому решению, это преобразование выдает размер массива.

## Индексы массива в цикле

В некоторых случаях обхода значений массива в цикле будет недостаточно. Нам может понадобиться и 
значение, и индекс. В этом случае нужно обойти в цикле индексы массива и получить с их помощью 
значения:

```perl
my @names = ("Foo", "Bar", "Baz");
foreach my $i (0 .. $#names) {
  say "$i - $names[$i]";
}
```

выведет:

```
0 - Foo
1 - Bar
2 - Baz
```

## push в массивах Perl

Функция `push` добавляет новое значение в конец массива, расширяя его:

```perl
my @names = ("Foo", "Bar", "Baz");
push @names, 'Moo';

say Dumper \@names;
```

Результат выполнения кода:

```
$VAR1 = [
        'Foo',
        'Bar',
        'Baz',
        'Moo'
      ];
```


## pop в массивах Perl

Функция `pop` извлекает последний элемент из массива:

```perl
my @names = ("Foo", "Bar", "Baz");
my $last_value = pop @names;
say "Last: $last_value";
say Dumper \@names;
```

Результат выполнения кода:

```
Last: Baz
$VAR1 = [
        'Foo',
        'Bar',
      ];
```

## shift в массивах Perl

Функция `shift` возвращает первый элемент массива и сдвигает остальные элементы влево.

```perl
my @names = ("Foo", "Bar", "Baz");

my $first_value = shift @names;
say "First: $first_value";
say Dumper \@names;
```

Результат выполнения кода:

```
First: Foo
$VAR1 = [
        'Bar',
        'Baz',
      ];
```


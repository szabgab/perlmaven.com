=title Use of uninitialized value
=timestamp 2013-07-09T08:00:05
=indexes undef, uninitialized value, $|, warnings, buffering
=status show
=original use-of-uninitialized-value
=books beginner
=author szabgab
=translator spidamoo
=comments_disqus_enable 0

=abstract start

Это одно из самых распространенных предупреждений, которые встречаются, когда запускаешь Perl-код.

Это предупреждение, так что оно не помешает вашему скрипту выполниться, и оно выдается только если
предупреждения были включены. (Что рекомендуется делать)

Обычно предупреждения включают с помощью выражения <hl>use warnings;</hl> в начале вашего скрипта
или модуля.

=abstract end

Старый способ - добавить флаг <hl>-w</hl> в консоли. Обычно так выглядит первая строка такого 
скрипта:

<hl>#!/usr/bin/perl -w</hl>

Существуют некоторые различия, но, поскольку <hl>use warnings</hl> доступно на текущий момент вот
уже 12 лет, нет причины избегать его. Другими словами:

Всегда используйте <hl>use warnings;</hl>!


Теперь давайте вернемся собственно к тому предупреждению, значение которого мы хотели объяснить в 
этой статье.

<h2>Быстрое объяснение</h2>

<code>
Use of uninitialized value $x in say at perl_warning_1.pl line 6.
</code>

Это значит, что у переменной <hl>$x</hl> нет значения (ей присвоено специальное значение 
<hl>undef</hl>). Либо у нее и не было никакого значения, либо в какой-то момент ей присвоили 
значение <hl>undef</hl>.

Нужно найти место, где этой переменной присвоено ее последнее значение, или понять, почему эта часть
кода так и не выполнилась.

<h2>Простой пример</h2>

Следующий пример выдаст такое предупреждение.

<code lang="perl">
use warnings;
use strict;
use 5.010;

my $x;
say $x;
</code>

Perl сообщит нам, в каком файле и на какой строке возникло это предупреждение (очень мило с его 
стороны).

<h2>Лишь предупреждение</h2>

Как уже упоминалось, это лишь предупреждение. Если в скрипте есть еще выражения после этого 
<hl>say</hl>, они будут выполнены.

<code lang="perl">
use warnings;
use strict;
use 5.010;

my $x;
say $x;
$x = 42;
say $x;
</code>

Результат выполнения этого кода:

<code>
Use of uninitialized value $x in say at perl_warning_1.pl line 6.

42
</code>

<h2>Смущающий порядок вывода</h2>

Однако будьте внимательны, если в вашем коде есть выражения <hl>print</hl> до строки, выдающей
предупреждение, как в этом примере:

<code lang="perl">
use warnings;
use strict;
use 5.010;

print 'OK';
my $x;
say $x;
$x = 42;
say $x;
</code>

результат может вас смутить.

<code>
Use of uninitialized value $x in say at perl_warning_1.pl line 7.
OK
42
</code>

Здесь мы видим вывод 'OK' <b>после</b> предупреждения, хотя вызов <h1>print</h1> производится 
<b>перед</b> кодом, выдающим предупреждение.

Эта странность - результат <h1>Буферизации ввода-вывода</h1>. По умолчанию Perl буферизирует STDOUT,
стандартный канал вывода, но не STDERR, стандартный канал для ошибок.

Так что, пока 'OK' ждет высвобождения буфера, предупреждение уже выводится на экран.

<h2>Выключение буферизации</h2>

Чтобы избежать этого, вы можете выключить буферизацию STDOUT.

Это можно сделать, добавив такой код: <hl>$| = 1;</hl> в начало скрипта.


<code lang="perl">
use warnings;
use strict;
use 5.010;

$| = 1;

print 'OK';
my $x;
say $x;
$x = 42;
say $x;
</code>

<code>
OKUse of uninitialized value $x in say at perl_warning_1.pl line 7.
42
</code>

(Предупреждение на одной строке с <b>OK</b>, потому что мы не вывели символ перевода строки 
<hl>\n</hl> после 'OK'.)

<h2>Нежелательная область видимости</h2>

<code lang="perl">
use warnings;
use strict;
use 5.010;

my $x;
my $y = 1;

if ($y) {
  my $x = 42;
}
say $x;
</code>

Этот код также выдает предупреждение <hl>Use of uninitialized value $x in say at perl_warning_1.pl 
line 11.</hl>

Я умудрился сделать эту ошибку несколько раз. Я не обратил внимания на то, что написал 
<hl>my $x</hl> внутри блока, чем создал новую переменную $x, присвоил ей значение 42 и позволил ей
исчезнуть в конце блока. ($y = 1 это просто замещение некоего настоящего кода с настоящим условием,
чтобы пример выглядил пореалистичнее.)

Конечно, существуют случаи, когда нужно объявить переменную внутри блока, но не всегда. Когда это
происходит по ошибке, поиск бага бывает очень болезненным.





=title @ARGV en Perl
=timestamp 2013-12-05T20:11:10
=indexes @ARGV, $ARGV[], $0, shift, argc
=status show
=original argv-in-perl
=books beginner
=author szabgab
=translator davidegx
=comments_disqus_enable 0

=abstract start

Si escribes un script Perl, por ejemplo <b>programming.pl</b>,
los usuarios pueden ejecutar el script en la línea de comandos usando <b>perl programming.pl</b>.

También pueden pasar parámetros como <b>perl programming.pl -a --machine remote /etc</b>.
No hay nada que impida a los usuarios hacerlo, el script descartará esos valores.
La cuestión es como puedes saber que parámetros fueron enviados al script.

=abstract end

<h2>La línea de comandos</h2>

Perl proporciona automáticamente un array llamado <hl>@ARGV</hl>, que contiene todos los valores enviados desde
la línea de comandos.
No tienes que declarar esta variable, incluso si usas <hl>use strict</hl>.

Esta variable siempre existe y contiene los valores pasados desde la línea de comandos de forma automática.

Si no hay parámetros, el array estará vacío. Si solo hay uno ese será el único elemento en <hl>@ARGV</hl>. En
el ejemplo anterior <hl>@ARGV</hl> contendrá:
-a, --machime, remote, /etc

Veámoslo en acción, guarda este código como <b>programming.pl</b>:

<code lang="perl">
use strict;
use warnings;
use Data::Dumper qw(Dumper);

print Dumper \@ARGV;
</code>

Ejecuta: <hl>perl programming.pl -a --machine remote /etc</hl> y este será el resultado:

<code>
$VAR1 = [
          '-a',
          '--machine',
          'remote',
          '/etc'
        ];
</code>

Como puedes ver usamos <hl>Dumper</hl> del modulo <hl>Data::Dumper</hl> para mostrar
el contenido de <hl>@ARGV</hl>

Si vienes de otro lenguaje de programación puedes preguntarte:
<b>¿Donde esta el nombre del programa?</b>

<h2>El nombre del script esta en $0</h2>

El nombre del programa que esta siendo ejecutado, en el ejemplo anterior <b>programming.pl</b>, esta siempre
en la variable <hl>$0</hl>. (Ten en cuenta que <hl>$1</hl>, <hl>$2</hl>, etc. son variables que no tienen nada
que ver)

<h2>Programador C</h2>

En caso de que sepas programar en C, <b>argv</b> es similar a <b>@ARGV</b>, pero <b>@ARGV</b> en
Perl <b>no</b> contiene el nombre del programa.
Puedes encontrarlo en la variable <hl>$0</hl>. Además una variable como <b>argc</b> no es necesaria,
puedes obtener fácilmente el <a href="/contexto-escalar-y-lista-en-perl"> número de elementos en el array @ARGV</a> usando la función
<hl>scalar</hl> o evaluando el array en <a href="/contexto-escalar-y-lista-en-perl">contexto escalar</a>.

<h2>Programación Unix/Linux</h2>

Si provienes del mundo de la <b>programación Unix/Linux Shell</b> reconocerás que la variable <hl>$0</hl>
es el nombre del script también. Sin embargo, en shell <hl>$1</hl>, <hl>$2</hl>, etc. contienen el resto
de los parámetros enviados al script. Estas variables son usadas por las expresiones regulares de Perl.
Los parámetros de la línea de comandos están en <hl>@ARGV</hl>. Similar a <hl>$*</hl> en Unix/Linux shell.

<h2>Como obtener los parámetros desde @ARGV</h2>

<hl>@ARGV</hl> es simplemente un <a href="arrays-en-perl">array Perl</a>.
La única diferencia con los arrays que tú creas, es que no hay necesidad de declararlo
y es rellenado automáticamente por Perl cuando el programa arranca.

Aparte de eso, puedes manipularlo como un <a href="https://perlmaven.com/perl-arrays">array</a> normal.
Puedes iterar sobre sus elementos usando <hl>foreach</hl>, o acceder a uno de ellos usando un índice: <hl>$ARGV[0]</hl>.

También puedes usar <a href="https://perlmaven.com/manipulating-perl-arrays">shift, unshift, pop o push</a> en este array.

De hecho no solo puedes obtener el contenido de <hl>@ARGV</hl>, también puedes modificarlo.

Si esperas un solo valor puedes comprobar su valor mirando <hl>$ARGV[0]</hl>. Si esperas
dos valores el segundo valor estará en <hl>$ARGV[1]</hl>.

Como ejemplo crearemos una agenda sencilla. Si proporcionas un nombre la aplicación mostrará
el teléfono correspondiente. Si indicas un nombre y un número el programa guardará esos valores
en la "base de datos". (No realizaremos el código relacionado con la base de datos, simplemente
imaginaremos que esta ahí.)

Sabemos que los parámetros llegarán en <hl>$ARGV[0]</hl> y quizás también en <hl>$ARGV[1]</hl>, pero
estos valores no tienen ningún significado aparte de ser el primer y segundo elemento del array.
Normalmente es mejor usar tus propias variables en el código en lugar de $ARGV[0] y similares.
Por tanto lo primero que haremos será copiar estos valores a variables con nombres más apropiados:

Por ejemplo:

<code lang="perl">
my $name   = $ARGV[0];
my $number = $ARGV[1];
</code>

O mejor todavía:

<code lang="perl">
my ($name, $number) = @ARGV;
</code>

Veamos un ejemplo completo (excepto por la parte de la base de datos).
Guarda el siguiente código en <b>programming.pl</b>.

<code lang="perl">
use strict;
use warnings;

my ($name, $number) = @ARGV;

if (not defined $name) {
  die "Need name\n";
}

if (defined $number) {
  print "Save '$name' and '$number'\n";
  # guarda el nombre/número en la base de datos
  exit;
}

print "Fetch '$name'\n";
# busca el nombre en la base de datos y lo muestra
</code>

Después de copiar los valores de <hl>@ARGV</hl>, comprobamos si se proporcionó un nombre.
Si no, llamamos a <hl>die</hl> que mostrará un mensaje de error y saldrá del script.

Si había un nombre, comprobaremos el número. Si hay un número lo guardaremos
en la base de datos (que no esta implementada) y saldremos del script.

Si no hay número se buscará en la base de datos. (De nuevo, no implementado.)

Veamos como funciona: (El símbolo $ solo marca el prompt, no hay que escribirlo.)

<code>
$ perl programming.pl Foo 123
Guarda 'Foo' y '123'

$ perl programming.pl Bar 456
Guarda 'Bar' y '456'

$ perl programming.pl John Doe 789
Guarda 'John' y 'Doe'
</code>

Las dos primeras llamadas fueron correctas, pero la última no.
Nuestra intención era guardar el teléfono de "John Doe", pero en su lugar
nuestro script guardo el teléfono de "Jonh" como si fuese "Doe".

La razón es simple, y no tiene nada que ver con Perl. Funcionaría de la misma manera en otros lenguajes.
La línea de comandos, donde ejecutas los scripts desarma la línea y pasa los valores a perl que entonces los
pone en <hl>@ARGV</hl>. Tanto como la shell de Unix/Linux y la línea de comandos en Windows dividen la línea
en cada espacio. Cuando escribimos <hl>perl programming.pl Jonh Doe 789</hl>, la shell pasará 3 parámetros
a nuestro script. Para hacerlo funcionar de manera correcta el usuario debe poner los valores que tienen
espacios entre comillas:

<code>
$ perl a.pl "John Doe" 789
Guarda 'John Doe' y '789'
</code>

Como programador no puedes hacer mucho acerca de este problema.

<h2>Comprobando los parámetros</h2>

Quizás puedas comprobar que el número de elementos no sobrepase el número de parámetros que esperas.
Evitaría que el usuario cometiese el error anterior, pero si el usuario quiere obtener
el número de Jonh Doe y olvida las comillas:

<code>
perl a.pl John Doe
Guarda 'John' y 'Doe'
</code>

En este caso hay 2 parámetros que es el número correcto.

Aquí también se puede hacer una pequeña mejora comprobando que el contenido de la variable <hl>$number</hl>
tiene un formato correcto para ser aceptado como número de teléfono. Esto reduciría la posibilidad de 
cometer errores para este caso.
No sería perfecto y no es una solución universal: en otros programas puede haber varios parámetros
que sean del mismo tipo.

Desafortunadamente no hay mucho que podamos hacer cuando analizamos <hl>@ARGV</hl> manualmente.
En otro articulo hablaré sobre <hl>Getopt::Long</hl> y librerías similares que pueden hacer la vida
un poco más sencilla.

<h2>Obtener un único parámetro con shift</h2>

Un caso típico es cuando esperas que el usuario proporcione un único fichero en la línea de comandos.
En ese caso puedes escribir el siguiente código:

<code lang="perl">
my $filename = shift or die "Usa: $0 FILENAME\n";
</code>

Partamos la línea en dos partes para entenderlo mejor:
<hl>my $filename = shift</hl>

Normalmente <a href="https://perlmaven.com/manipulating-perl-arrays">shift</a> recibe un array como parámetro
pero en este caso la usamos sin ningún parámetro. Cuando no hay ningún parámetro  shift usa por defecto
la variable <hl>@ARGV</hl>. (Si el código no esta dentro de una función)

Después tenemos el siguiente código:
<hl>$filename or die "Usa: $0 FILENAME\n"</hl>

Esto es una expresión <a href="/valores-booleanos-en-perl">booleana</a>.
Si <hl>$filename</hl> contiene el nombre de un fichero entonces será
<a href="/valores-booleanos-en-perl">considerado Verdadero</a> y el script continuará
sin ejecutar la parte <hl>or die ...</hl>.
Por otro lado, si @ARGV estaba vacío, <hl>undef</hl> será asignado a <hl>$filename</hl>,
y la expresión será <a href="/valores-booleanos-en-perl">considerada Falsa</a>
y Perl ejecutará la parte derecha del la sentencia <hl>or</hl>, mostrando un mensaje
en la pantalla y saliendo del script.

Básicamente este fragmento de código comprueba si un parámetro fue pasado desde la línea
de comandos y lo copia a la variable <hl>$filename</hl>. Si no se proporciono ningún valor
el script terminará con error mediante <hl>die</hl>

<h2>Pequeño bug</h2>

Hay un pequeño error en el código anterior. Si el usuario tiene un fichero con llamado 0 la expresión
será Falsa y el script no podrá procesar ese fichero. La cuestión es: ¿Realmente importa?
¿Podemos vivir con el hecho de que nuestro script no sea capaz de procesar un fichero llamado <b>0<b/>?

<h2>Casos complejos</h2>

Hay un montón de casos que son mucho más complicados que el ejemplo anterior.
En dichos casos probablemente te interese usar un modulo como <hl>Getop::Long</hl> que es capaz
de analizar el contenido de <hl>@ARGV</hl> en base a una declaración de los parámetros que quieres
recibir en tu script.



